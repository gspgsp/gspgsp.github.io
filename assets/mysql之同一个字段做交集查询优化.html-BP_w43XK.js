import{_ as e,c as s,d as n,o as i}from"./app-CHrRue27.js";const a={};function d(l,t){return i(),s("div",null,t[0]||(t[0]=[n('<p>mysql之同一个字段做交集查询优化: 最近做了一个这样的需求，对同一个字段做条件筛选，开始比较纠结，怎么做效率更高，主要有如下两种方案：</p><div class="language-text line-numbers-mode" data-highlighter="prismjs" data-ext="text" data-title="text"><pre><code><span class="line">通过多个 exists对同一个字段(这里正好是等值查询)做交集查询:</span>\n<span class="line">SELECT `id`,`name`,`cover_image`,`price`,`score`,`remark`,`brand`,`subclass`,`category_one`,`category_two`,`detail` FROM `d_products` WHERE (kind = &#39;养老服务&#39; and (name like &#39;%水%&#39; or detail like &#39;%水%&#39;)) AND (EXISTS(SELECT id FROM d_product_attributes WHERE `d_product_attributes`.`product_id`  = `d_products`.`id` AND `d_product_attributes`.`attribute_value` = &#39;卫浴&#39;) and EXISTS(SELECT id FROM d_product_attributes WHERE `d_product_attributes`.`product_id`  = `d_products`.`id` AND `d_product_attributes`.`attribute_value` = &#39;介护老人&#39;) and EXISTS(SELECT id FROM d_product_attributes WHERE `d_product_attributes`.`product_id`  = `d_products`.`id` AND `d_product_attributes`.`attribute_value` = &#39;防滑&#39;)) ORDER BY id desc LIMIT 10;</span>\n<span class="line"></span>\n<span class="line"></span>\n<span class="line">explain结果：</span>\n<span class="line">explain结果：</span>\n<span class="line">id   | select_type          | table                   | partitions    | type | possible_keys           |  key                 | key_len | ref  | rows | filtered | Extra</span>\n<span class="line">1	   PRIMARY	            d_japan_products		                    ref	    index_kind	            index_kind	            768	     const	 1276	20.99	Using where</span>\n<span class="line">3	  DEPENDENT SUBQUERY	d_japan_product_attributes		            ref	    attribute_value-index	attribute_value-index	768	     const	 669	10	    Using where</span>\n<span class="line">2	  DEPENDENT SUBQUERY	d_japan_product_attributes		            ref	    attribute_value-index	attribute_value-index	768	     const	 538	10	    Using where</span>\n<span class="line"></span>\n<span class="line"></span>\n<span class="line"></span>\n<span class="line">通过单个exists 配合 or 范围查询实现:</span>\n<span class="line">SELECT `id`,`name`,`cover_image`,`price`,`score`,`remark`,`brand`,`subclass`,`category_one`,`category_two`,`detail` FROM `d_products` WHERE (kind = &#39;养老服务&#39; and (name like &#39;%水%&#39; or detail like &#39;%水%&#39;)) AND (EXISTS(SELECT count(id) as id_count FROM `d_product_attributes` WHERE `d_product_attributes`.`product_id` = `d_products`.`id` AND (`d_product_attributes`.`attribute_value` = &#39;卫浴&#39; or `d_product_attributes`.`attribute_value` = &#39;介护老人&#39;) group by `d_product_attributes`.`product_id` HAVING id_count = 2)) ORDER BY id desc LIMIT 10;</span>\n<span class="line"></span>\n<span class="line"></span>\n<span class="line">explain结果：</span>\n<span class="line">id   | select_type          | table                   | partitions    | type | possible_keys           |  key                 | key_len | ref  | rows | filtered | Extra</span>\n<span class="line">1	   PRIMARY	            d_japan_products		                   ref	    index_kind	            index_kind	            768	     const	1276	20.99	Using where</span>\n<span class="line">2	   DEPENDENT SUBQUERY	d_japan_product_attributes		           range	attribute_value-index	attribute_value-index	768		        1207	10	    Using index condition; Using where; Using temporary; Using filesort</span>\n<span class="line"></span>\n<span class="line"></span>\n<span class="line">总结：对比可以知道，通过第一种方式查询的更快一些，原因是 第一种 会用到等值查询配合 attribute_value 字段上的索引会非常快，一个 type 是 ref,另一个 type 是 range</span>\n<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>',2)]))}const c=e(a,[["render",d],["__file","mysql之同一个字段做交集查询优化.html.vue"]]),p=JSON.parse('{"path":"/content/database/mysql/mysql%E4%B9%8B%E5%90%8C%E4%B8%80%E4%B8%AA%E5%AD%97%E6%AE%B5%E5%81%9A%E4%BA%A4%E9%9B%86%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96.html","title":"mysql之同一个字段做交集查询优化","lang":"en-US","frontmatter":{"sidebar":false,"title":"mysql之同一个字段做交集查询优化","description":"mysql之同一个字段做交集查询优化"},"headers":[],"git":{},"filePathRelative":"content/database/mysql/mysql之同一个字段做交集查询优化.md"}');export{c as comp,p as data};
