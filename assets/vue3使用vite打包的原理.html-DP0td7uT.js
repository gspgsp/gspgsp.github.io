import{_ as s,c as a,f as e,o as t}from"./app-BB_BIQV8.js";const p={};function o(l,n){return t(),a("div",null,n[0]||(n[0]=[e(`<h5 id="vue3使用vite打包的原理" tabindex="-1"><a class="header-anchor" href="#vue3使用vite打包的原理"><span>vue3使用vite打包的原理</span></a></h5><p>缘起: <strong>Vue3 + Vite</strong> 为什么 <code>npm run dev</code> 一跑就能看到访问连接：</p><h5 id="_1-vite-的核心原理" tabindex="-1"><a class="header-anchor" href="#_1-vite-的核心原理"><span>1. Vite 的核心原理</span></a></h5><p>Vite 的名字来自法语 <strong>&quot;vite&quot; = 快速</strong>。它的核心理念就是<strong>利用浏览器原生 ES Module 能力</strong>，避免传统构建工具（Webpack/Rollup）那种“先打包再启动”的流程。</p><ul><li><p><strong>传统打包工具</strong>（Webpack）：</p><ul><li>启动时会把整个项目打包成一个 bundle 文件（或多个 chunk）。</li><li>大项目启动时要等很久才能看到页面。</li></ul></li><li><p><strong>Vite</strong>：</p><ul><li>启动时<strong>不打包</strong>，只是起一个开发服务器。</li><li>浏览器请求哪个文件，就<strong>按需即时编译</strong>（on-demand transformation），用 ES Module 直接返回。</li><li>这样启动速度非常快。</li></ul></li></ul><h5 id="_2-为什么-npm-run-dev-就能看到链接" tabindex="-1"><a class="header-anchor" href="#_2-为什么-npm-run-dev-就能看到链接"><span>2. 为什么 <code>npm run dev</code> 就能看到链接</span></a></h5><p>通常在 <code>package.json</code> 里会有这样一行：</p><div class="language-json line-numbers-mode" data-highlighter="prismjs" data-ext="json" data-title="json"><pre><code><span class="line"><span class="token property">&quot;scripts&quot;</span><span class="token operator">:</span> <span class="token punctuation">{</span></span>
<span class="line">  <span class="token property">&quot;dev&quot;</span><span class="token operator">:</span> <span class="token string">&quot;vite&quot;</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>当你执行 <code>npm run dev</code> 时，本质上是调用了 <strong>vite CLI</strong>（开发服务器）。它的执行流程是这样的：</p><ol><li><p><strong>读取配置</strong></p><ul><li>Vite 会读取 <code>vite.config.ts</code> 或 <code>vite.config.js</code>（如果有）。</li><li>同时识别项目入口（默认是 <code>index.html</code>）。</li></ul></li><li><p><strong>启动开发服务器</strong></p><ul><li>Vite 内置了一个基于 <a href="https://github.com/senchalabs/connect" target="_blank" rel="noopener noreferrer">connect</a> 的 dev server。</li><li>监听一个端口（默认 <code>5173</code>）。</li><li>输出类似 <code>http://localhost:5173/</code> 的访问链接。</li></ul></li><li><p><strong>拦截浏览器请求</strong></p><ul><li>浏览器访问 <code>http://localhost:5173/</code> 时，Vite 会返回 <code>index.html</code>。</li><li>当 <code>index.html</code> 里引用了 <code>src/main.ts</code>，Vite 就会动态编译这个文件，并以 <strong>ESM 模块</strong>的形式返回给浏览器。</li><li>如果 <code>main.ts</code> 又 import 了 Vue 组件，Vite 会继续即时编译这些 <code>.vue</code> 文件（通过 <code>@vitejs/plugin-vue</code> 插件）。</li></ul></li><li><p><strong>热更新 (HMR)</strong></p><ul><li>Vite 内置 WebSocket 连接。</li><li>当文件修改时，Vite 只会重新编译<strong>变动的文件</strong>，并通过 HMR 更新浏览器里的模块，而不是整个页面刷新。</li><li>这就是为什么改一个组件页面能秒级看到变化。</li></ul></li></ol><h5 id="_3-为什么能直接访问-vue3-代码" tabindex="-1"><a class="header-anchor" href="#_3-为什么能直接访问-vue3-代码"><span>3. 为什么能直接访问 Vue3 代码</span></a></h5><p>因为 <strong>Vite 把 Vue 文件和 TypeScript 等等转译成浏览器可运行的 ESM</strong>：</p><ul><li><code>.vue</code> 文件 → 转成 JS 模块（render function + script）</li><li><code>.ts</code> 文件 → 用 esbuild 转成 JS</li><li>依赖包（比如 <code>vue</code>）→ 预构建成单个 ESM（用 esbuild 优化）</li></ul><p>所以浏览器收到的都是标准的 JS 模块，能直接运行。</p><p>✅ 总结：</p><ul><li><code>npm run dev</code> 启动的是 <strong>Vite 的开发服务器</strong>。</li><li>Vite 的原理是 <strong>利用浏览器原生 ES Modules</strong>，做到即开即用、按需编译。</li><li>浏览器访问链接后，Vite 会按需编译并返回文件，同时通过 HMR 实现热更新。</li></ul><hr><h5 id="什么是es-moudle" tabindex="-1"><a class="header-anchor" href="#什么是es-moudle"><span>什么是ES Moudle？</span></a></h5><p><strong>关键点：ESM 模块</strong>。</p><p><code>npm run dev</code> 之所以能让 Vue3 + Vite 立即跑起来，核心就在 <strong>ESM（ES Modules，原生模块化标准）</strong>。我给你拆一下：</p><h5 id="_1-什么是-esm-模块" tabindex="-1"><a class="header-anchor" href="#_1-什么是-esm-模块"><span>1. 什么是 ESM 模块</span></a></h5><p>ESM 是 <strong>浏览器和 Node.js 官方支持的模块化规范</strong>，用 <code>import / export</code> 来组织代码。 例如：</p><div class="language-javascript line-numbers-mode" data-highlighter="prismjs" data-ext="js" data-title="js"><pre><code><span class="line"><span class="token comment">// math.js</span></span>
<span class="line"><span class="token keyword">export</span> <span class="token keyword">function</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token parameter">a<span class="token punctuation">,</span> b</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">  <span class="token keyword">return</span> a <span class="token operator">+</span> b</span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span>
<span class="line"><span class="token comment">// main.js</span></span>
<span class="line"><span class="token keyword">import</span> <span class="token punctuation">{</span> add <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">&#39;./math.js&#39;</span></span>
<span class="line">console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">)</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>📌 关键点：</p><ul><li>浏览器可以 <strong>原生识别 <code>import</code></strong>（不用打包工具）</li><li>每个模块文件就是一个 <strong>独立作用域</strong></li><li>按需加载，避免一次性打包成大文件</li></ul><h5 id="_2-vite-为什么要用-esm" tabindex="-1"><a class="header-anchor" href="#_2-vite-为什么要用-esm"><span>2. Vite 为什么要用 ESM</span></a></h5><p>Vite 在开发模式下，完全依赖浏览器的 ESM 特性：</p><ol><li><p>你访问 <code>http://localhost:5173/</code> 时，<code>index.html</code> 里会写：</p><div class="language-html line-numbers-mode" data-highlighter="prismjs" data-ext="html" data-title="html"><pre><code><span class="line"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>module<span class="token punctuation">&quot;</span></span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>/src/main.ts<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span><span class="token script"></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">&gt;</span></span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>浏览器看到 <code>type=&quot;module&quot;</code>，就会去请求 <code>/src/main.ts</code>。</p></li><li><p>Vite 拦截这个请求：</p><ul><li>如果是 <code>.ts</code> → 用 <strong>esbuild</strong> 转译成 JS</li><li>如果是 <code>.vue</code> → 用插件转成 JS 模块（render + script）</li><li>如果是依赖（如 <code>vue</code>）→ 提前 <strong>预构建</strong> 成 ESM（避免 <code>node_modules</code> 太多小文件导致请求过多）</li></ul></li><li><p>浏览器再按需加载这些 JS 模块，形成一个 <strong>模块依赖树</strong>。</p><ul><li>改一个文件，Vite 只需要重新编译这个文件，并通过 HMR 替换模块，而不是整个页面刷新。</li></ul></li></ol><h5 id="_3-为什么-esm-vite-极速开发体验" tabindex="-1"><a class="header-anchor" href="#_3-为什么-esm-vite-极速开发体验"><span>3. 为什么 ESM = Vite 极速开发体验</span></a></h5><ul><li><strong>不用一次性打包</strong> → 启动极快</li><li><strong>模块天然分割</strong> → 修改一个模块时，只更新这个模块（HMR）</li><li><strong>浏览器直接支持</strong> → 少了一层构建的中间步骤</li></ul><p>✅ 总结： Vite 的核心就是<strong>基于浏览器原生 ESM 模块</strong>，把每个 <code>.vue</code>、<code>.ts</code>、依赖都当作独立的 ESM 来处理。 这也是它比 Webpack/Gulp 那些工具快得多的根本原因。</p><hr><h5 id="es-modules-分类" tabindex="-1"><a class="header-anchor" href="#es-modules-分类"><span>ES Modules 分类</span></a></h5><p>在 Vite 的 <strong>开发模式</strong> 下，最后所有代码都会变成 <strong>ES Modules (ESM)</strong>，再交给浏览器去执行。 不过这里要分三类情况来看：</p><h5 id="_1-你的源码-vue、-ts、-js" tabindex="-1"><a class="header-anchor" href="#_1-你的源码-vue、-ts、-js"><span>1. 你的源码（<code>.vue</code>、<code>.ts</code>、<code>.js</code>）</span></a></h5><ul><li><p><code>.vue</code> 文件 → 通过 <code>@vitejs/plugin-vue</code> 编译成 JS 模块：</p><div class="language-javascript line-numbers-mode" data-highlighter="prismjs" data-ext="js" data-title="js"><pre><code><span class="line"><span class="token comment">// App.vue → 编译后</span></span>
<span class="line"><span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token punctuation">{</span></span>
<span class="line">  <span class="token function">render</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token operator">...</span> <span class="token punctuation">}</span><span class="token punctuation">,</span></span>
<span class="line">  <span class="token function">setup</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token operator">...</span> <span class="token punctuation">}</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li><li><p><code>.ts</code> 文件 → 用 <strong>esbuild</strong> 转成 JS，再包装成 ESM：</p><div class="language-typescript line-numbers-mode" data-highlighter="prismjs" data-ext="ts" data-title="ts"><pre><code><span class="line"><span class="token comment">// main.ts</span></span>
<span class="line"><span class="token keyword">import</span> <span class="token punctuation">{</span> createApp <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">&#39;vue&#39;</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><p>→ 转译后仍然是 <code>import</code> 语法，浏览器直接识别。</p></li></ul><p>👉 最终：每个源码文件就是一个 <strong>独立的 ESM 模块</strong>。</p><h5 id="_2-依赖包-node-modules-里的第三方库" tabindex="-1"><a class="header-anchor" href="#_2-依赖包-node-modules-里的第三方库"><span>2. 依赖包（<code>node_modules</code> 里的第三方库）</span></a></h5><p>这里是 Vite 的一个 <strong>优化点</strong>：</p><ul><li><code>node_modules</code> 里的库（例如 <code>vue</code>, <code>lodash-es</code>）有的不是 ESM 格式，而是 CommonJS 或 UMD。</li><li>Vite 会在<strong>启动时做依赖预构建（dependency pre-bundling）</strong>，把这些库用 <strong>esbuild</strong> 转换成 ESM 格式。</li></ul><p>比如 <code>vue</code> 最终会被处理成一个 ESM 文件放在：</p><div class="language-text line-numbers-mode" data-highlighter="prismjs" data-ext="text" data-title="text"><pre><code><span class="line">node_modules/.vite/deps/vue.js</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>👉 所以即便原始库不是 ESM，Vite 也会先帮你“转译成 ESM”，保证浏览器能用。</p><h5 id="_3-最终效果" tabindex="-1"><a class="header-anchor" href="#_3-最终效果"><span>3. 最终效果</span></a></h5><ul><li><p>开发模式下： 所有请求的文件（Vue/TS/依赖包）最后都是 <strong>ES Modules</strong>，浏览器原生加载。</p></li><li><p>生产模式下（<code>vite build</code>）： Vite 会调用 Rollup，把所有模块打包、拆分优化（代码分块、Tree Shaking、压缩）。 <strong>最终线上跑的不是一堆 ESM 文件，而是构建后的 bundle</strong>，这样减少网络请求数、提升性能。</p></li></ul><p>📌 <strong>总结一句话</strong>：</p><ul><li><strong>开发模式</strong>：所有 <code>.vue</code>、<code>.ts</code>、依赖包 → 全部转成 ESM，浏览器直接按需加载。</li><li><strong>生产模式</strong>：Vite 会再把这些 ESM 模块交给 Rollup 打包优化，生成少量高效的产物。</li></ul><hr><h5 id="type-module-的作用" tabindex="-1"><a class="header-anchor" href="#type-module-的作用"><span>type=&quot;module&quot;的作用</span></a></h5><p>好问题 👍，<code>&lt;script type=&quot;module&quot;&gt;</code> 正是 Vite 能在浏览器里直接跑的关键。</p><h5 id="_1-背景" tabindex="-1"><a class="header-anchor" href="#_1-背景"><span>1. 背景</span></a></h5><p>在最早的浏览器里，JavaScript 只有 <strong>全局脚本</strong>：</p><div class="language-html line-numbers-mode" data-highlighter="prismjs" data-ext="html" data-title="html"><pre><code><span class="line"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>main.js<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span><span class="token script"></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">&gt;</span></span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>所有变量、函数都挂在 <code>window</code> 上，容易冲突，也没办法分模块管理。</p><p>后来有了各种 <strong>模块化方案</strong>：</p><ul><li>CommonJS（Node.js 用的 <code>require()</code>）</li><li>AMD/UMD（浏览器异步模块加载） 但这些都是“约定俗成”，浏览器并不原生支持。</li></ul><p>直到 <strong>ESM（ECMAScript Modules）</strong> 标准推出，浏览器原生支持 <code>import/export</code>，才有了今天的 <code>&lt;script type=&quot;module&quot;&gt;</code>。</p><h5 id="_2-type-module-的作用" tabindex="-1"><a class="header-anchor" href="#_2-type-module-的作用"><span>2. <code>type=&quot;module&quot;</code> 的作用</span></a></h5><p>当你写：</p><div class="language-html line-numbers-mode" data-highlighter="prismjs" data-ext="html" data-title="html"><pre><code><span class="line"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>module<span class="token punctuation">&quot;</span></span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>/src/main.js<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span><span class="token script"></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">&gt;</span></span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>它和普通 <code>&lt;script&gt;</code> 有这些区别：</p><h5 id="✅-支持-esm-语法" tabindex="-1"><a class="header-anchor" href="#✅-支持-esm-语法"><span>✅ 支持 ESM 语法</span></a></h5><p>可以在浏览器里直接写：</p><div class="language-javascript line-numbers-mode" data-highlighter="prismjs" data-ext="js" data-title="js"><pre><code><span class="line"><span class="token keyword">import</span> <span class="token punctuation">{</span> createApp <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">&#39;vue&#39;</span></span>
<span class="line"><span class="token keyword">import</span> App <span class="token keyword">from</span> <span class="token string">&#39;./App.vue&#39;</span></span>
<span class="line"></span>
<span class="line"><span class="token function">createApp</span><span class="token punctuation">(</span>App<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">mount</span><span class="token punctuation">(</span><span class="token string">&#39;#app&#39;</span><span class="token punctuation">)</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>浏览器会自动去请求并执行这些模块。</p><h5 id="✅-默认是-延迟加载-defer" tabindex="-1"><a class="header-anchor" href="#✅-默认是-延迟加载-defer"><span>✅ 默认是 <strong>延迟加载 (defer)</strong></span></a></h5><p>等 DOM 解析完再执行，避免阻塞页面加载。 （普通 <code>&lt;script&gt;</code> 会阻塞解析）</p><h5 id="✅-每个模块有自己的作用域" tabindex="-1"><a class="header-anchor" href="#✅-每个模块有自己的作用域"><span>✅ 每个模块有自己的作用域</span></a></h5><p>不会像普通 <code>&lt;script&gt;</code> 那样污染全局变量。 模块之间通过 <code>import/export</code> 明确依赖关系。</p><h5 id="✅-自动开启严格模式-use-strict" tabindex="-1"><a class="header-anchor" href="#✅-自动开启严格模式-use-strict"><span>✅ 自动开启严格模式 (<code>use strict</code>)</span></a></h5><p>提升代码安全性，比如不能随便用未声明的变量。</p><h5 id="✅-可以加载远程模块" tabindex="-1"><a class="header-anchor" href="#✅-可以加载远程模块"><span>✅ 可以加载远程模块</span></a></h5><p>甚至可以直接写 CDN 地址：</p><div class="language-html line-numbers-mode" data-highlighter="prismjs" data-ext="html" data-title="html"><pre><code><span class="line"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>module<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span><span class="token script"><span class="token language-javascript"></span>
<span class="line">  <span class="token keyword">import</span> _ <span class="token keyword">from</span> <span class="token string">&quot;https://cdn.skypack.dev/lodash-es&quot;</span></span>
<span class="line">  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>_<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token string">&quot;Hello&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;Vite&quot;</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token string">&quot; &quot;</span><span class="token punctuation">)</span><span class="token punctuation">)</span></span>
<span class="line"></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">&gt;</span></span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>（这也是 Vite 为什么可以直接利用浏览器的能力。）</p><h5 id="_3-在-vite-里的意义" tabindex="-1"><a class="header-anchor" href="#_3-在-vite-里的意义"><span>3. 在 Vite 里的意义</span></a></h5><p>当 Vite 返回 <code>index.html</code> 时，它会自动插入：</p><div class="language-html line-numbers-mode" data-highlighter="prismjs" data-ext="html" data-title="html"><pre><code><span class="line"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>module<span class="token punctuation">&quot;</span></span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>/src/main.ts<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span><span class="token script"></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">&gt;</span></span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>👉 浏览器一看到 <code>type=&quot;module&quot;</code> 就会触发 <strong>原生 ESM 加载流程</strong>：</p><ul><li>请求 <code>/src/main.ts</code></li><li>里面 <code>import App from &#39;./App.vue&#39;</code></li><li>浏览器继续请求 <code>/src/App.vue</code>（Vite 会在后台把它编译成 ESM）</li></ul><p>最终整个 Vue 项目就跑起来了。</p><p>✅ <strong>一句话总结</strong>： <code>type=&quot;module&quot;</code> 的作用是告诉浏览器：</p><blockquote><p>这个脚本是一个 <strong>ESM 模块</strong>，请按模块化规则加载（支持 <code>import/export</code>、作用域隔离、延迟执行）。</p></blockquote><hr><h5 id="关于connect" tabindex="-1"><a class="header-anchor" href="#关于connect"><span>关于connect</span></a></h5><p>https://github.com/senchalabs/connect</p><p>connect是一个 <strong>Node.js 里的 HTTP 中间件框架</strong>。</p><hr><h5 id="_1-什么是-connect" tabindex="-1"><a class="header-anchor" href="#_1-什么是-connect"><span>1. 什么是 <code>connect</code></span></a></h5><ul><li><code>connect</code> 是一个非常轻量的 Node.js 库，用来快速创建 HTTP 服务器。</li><li>它本质上是基于 <strong>Node.js 的 <code>http</code> 模块</strong>，在其上增加了 <strong>中间件机制</strong>。</li><li>Express（很流行的 Node 框架）就是在 <code>connect</code> 的基础上扩展出来的。</li></ul><p>简单示例：</p><div class="language-javascript line-numbers-mode" data-highlighter="prismjs" data-ext="js" data-title="js"><pre><code><span class="line"><span class="token keyword">import</span> connect <span class="token keyword">from</span> <span class="token string">&#39;connect&#39;</span></span>
<span class="line"><span class="token keyword">import</span> http <span class="token keyword">from</span> <span class="token string">&#39;http&#39;</span></span>
<span class="line"></span>
<span class="line"><span class="token keyword">const</span> app <span class="token operator">=</span> <span class="token function">connect</span><span class="token punctuation">(</span><span class="token punctuation">)</span></span>
<span class="line"></span>
<span class="line"><span class="token comment">// 注册中间件</span></span>
<span class="line">app<span class="token punctuation">.</span><span class="token function">use</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">req<span class="token punctuation">,</span> res<span class="token punctuation">,</span> next</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span></span>
<span class="line">  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&#39;Request URL:&#39;</span><span class="token punctuation">,</span> req<span class="token punctuation">.</span>url<span class="token punctuation">)</span></span>
<span class="line">  <span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span></span>
<span class="line"><span class="token punctuation">}</span><span class="token punctuation">)</span></span>
<span class="line"></span>
<span class="line">app<span class="token punctuation">.</span><span class="token function">use</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">req<span class="token punctuation">,</span> res</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span></span>
<span class="line">  res<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token string">&#39;Hello from Connect server&#39;</span><span class="token punctuation">)</span></span>
<span class="line"><span class="token punctuation">}</span><span class="token punctuation">)</span></span>
<span class="line"></span>
<span class="line"><span class="token comment">// 启动 HTTP 服务</span></span>
<span class="line">http<span class="token punctuation">.</span><span class="token function">createServer</span><span class="token punctuation">(</span>app<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">listen</span><span class="token punctuation">(</span><span class="token number">3000</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span></span>
<span class="line">  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&#39;Server running at http://localhost:3000&#39;</span><span class="token punctuation">)</span></span>
<span class="line"><span class="token punctuation">}</span><span class="token punctuation">)</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>运行后，你就有了一个 <code>http://localhost:3000</code> 的服务。</p><h5 id="_2-vite-为什么用-connect" tabindex="-1"><a class="header-anchor" href="#_2-vite-为什么用-connect"><span>2. Vite 为什么用 <code>connect</code></span></a></h5><p>当你执行 <code>npm run dev</code> 启动 Vite 开发服务器时：</p><ul><li><p>Vite 底层会创建一个 <strong>connect 应用</strong></p></li><li><p>然后注册各种中间件，例如：</p><ul><li>处理静态文件请求（返回 index.html、图片、CSS 等）</li><li>处理 ESM 请求（拦截 <code>.vue</code>、<code>.ts</code> 转译成 JS）</li><li>HMR WebSocket 通信</li></ul></li><li><p>最终由 Node.js 内置的 <code>http</code> 模块把这个服务跑起来</p></li></ul><p>所以你能在浏览器访问 <code>http://localhost:5173</code>，但真正的服务是 <strong>Node.js + connect</strong> 起的。</p><h5 id="_3-总结" tabindex="-1"><a class="header-anchor" href="#_3-总结"><span>3. 总结</span></a></h5><ul><li><code>connect</code> 是 <strong>Node.js 里的 HTTP 框架</strong>，不是浏览器的。</li><li>它给 Vite 提供了一个可扩展的 <strong>中间件体系</strong>。</li><li>浏览器只是作为客户端，请求 Vite 用 <code>connect</code> 起的本地服务。这个是重点，只负责启动一个本地服务。</li></ul>`,99)]))}const i=s(p,[["render",o],["__file","vue3使用vite打包的原理.html.vue"]]),u=JSON.parse('{"path":"/content/front/js/vue3%E4%BD%BF%E7%94%A8vite%E6%89%93%E5%8C%85%E7%9A%84%E5%8E%9F%E7%90%86.html","title":"vue3使用vite打包的原理","lang":"en-US","frontmatter":{"sidebar":false,"title":"vue3使用vite打包的原理","head":[["meta",{"name":"title","content":"vue3使用vite打包的原理"}],["meta",{"name":"description","content":"vue3使用vite打包的原理"}],["meta",{"name":"keywords","content":"vue3,vite"}],["meta",{"property":"og:title","content":"vue3使用vite打包的原理"}],["meta",{"property":"og:description","content":"vue3使用vite打包的原理"}]]},"headers":[],"git":{},"filePathRelative":"content/front/js/vue3使用vite打包的原理.md"}');export{i as comp,u as data};
