import{_ as s,c as a,d as i,o as t}from"./app-CHrRue27.js";const n={};function r(d,e){return t(),a("div",null,e[0]||(e[0]=[i(`<p>php项目用到消息队列，配置了redis，发现数据存储的是stream类型<br> 介绍:</p><div class="language-text line-numbers-mode" data-highlighter="prismjs" data-ext="text" data-title="text"><pre><code><span class="line">Redis Stream 是 Redis 5.0 版本新增加的数据结构。</span>
<span class="line">Redis Stream 主要用于消息队列（MQ，Message Queue），Redis 本身是有一个 Redis 发布订阅 (pub/sub) 来实现消息队列的功能，</span>
<span class="line">但它有个缺点就是消息无法持久化，如果出现网络断开、Redis 宕机等，消息就会被丢弃。</span>
<span class="line">简单来说发布订阅 (pub/sub) 可以分发消息，但无法记录历史消息。</span>
<span class="line">而 Redis Stream 提供了消息的持久化和主备复制功能，可以让任何客户端访问任何时刻的数据，并且能记住每一个客户端的访问位置，还能保证消息不丢失。</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>命令:</p><div class="language-text line-numbers-mode" data-highlighter="prismjs" data-ext="text" data-title="text"><pre><code><span class="line">redis&gt; XRANGE messages - + // 获取key messages 下的所有数据</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div>`,4)]))}const c=s(n,[["render",r],["__file","redis之stream类型.html.vue"]]),m=JSON.parse('{"path":"/content/database/redis/redis%E4%B9%8Bstream%E7%B1%BB%E5%9E%8B.html","title":"redis之stream类型","lang":"en-US","frontmatter":{"sidebar":false,"title":"redis之stream类型","description":"redis之stream类型"},"headers":[],"git":{},"filePathRelative":"content/database/redis/redis之stream类型.md"}');export{c as comp,m as data};
