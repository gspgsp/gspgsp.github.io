import{_ as e,c as n,f as a,o as l}from"./app-BB_BIQV8.js";const i={};function t(r,s){return l(),n("div",null,s[0]||(s[0]=[a(`<h3 id="关于redis的五大基本数据结构-redis-是一个内存型键值数据库-它支持多种数据类型-常用的5个基本数据类型如下" tabindex="-1"><a class="header-anchor" href="#关于redis的五大基本数据结构-redis-是一个内存型键值数据库-它支持多种数据类型-常用的5个基本数据类型如下"><span>关于Redis的五大基本数据结构, Redis 是一个内存型键值数据库，它支持多种数据类型，常用的<strong>5个基本数据类型</strong>如下：</span></a></h3><h3 id="_1️⃣-string-字符串" tabindex="-1"><a class="header-anchor" href="#_1️⃣-string-字符串"><span>1️⃣ <strong>String（字符串）</strong></span></a></h3><ul><li><p>最基本的数据类型，存储的是字符串，可以是文本或二进制数据。</p></li><li><p><strong>特点</strong>：</p><ul><li>单个 key 对应一个字符串值。</li><li>支持多种操作：设置、获取、追加、增减数值等。</li></ul></li><li><p><strong>常用命令</strong>：</p><div class="language-bash line-numbers-mode" data-highlighter="prismjs" data-ext="sh" data-title="sh"><pre><code><span class="line">SET key value      <span class="token comment"># 设置值</span></span>
<span class="line">GET key            <span class="token comment"># 获取值</span></span>
<span class="line">APPEND key value   <span class="token comment"># 追加值</span></span>
<span class="line">INCR key           <span class="token comment"># 自增</span></span>
<span class="line">DECR key           <span class="token comment"># 自减</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li></ul><hr><h3 id="_2️⃣-list-列表" tabindex="-1"><a class="header-anchor" href="#_2️⃣-list-列表"><span>2️⃣ <strong>List（列表）</strong></span></a></h3><ul><li><p>有序列表，底层是链表结构。</p></li><li><p><strong>特点</strong>：</p><ul><li>元素按插入顺序排序，可以从两端插入/弹出。</li><li>支持队列（FIFO）和栈（LIFO）操作。</li></ul></li><li><p><strong>常用命令</strong>：</p><div class="language-bash line-numbers-mode" data-highlighter="prismjs" data-ext="sh" data-title="sh"><pre><code><span class="line">LPUSH key value     <span class="token comment"># 从左侧插入</span></span>
<span class="line">RPUSH key value     <span class="token comment"># 从右侧插入</span></span>
<span class="line">LPOP key            <span class="token comment"># 从左侧弹出</span></span>
<span class="line">RPOP key            <span class="token comment"># 从右侧弹出</span></span>
<span class="line">LRANGE key <span class="token number">0</span> <span class="token parameter variable">-1</span>     <span class="token comment"># 获取整个列表</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li></ul><hr><h3 id="_3️⃣-set-集合" tabindex="-1"><a class="header-anchor" href="#_3️⃣-set-集合"><span>3️⃣ <strong>Set（集合）</strong></span></a></h3><ul><li><p>无序集合，不允许重复元素，底层是哈希表。</p></li><li><p><strong>特点</strong>：</p><ul><li>元素唯一性。</li><li>支持集合运算（交集、并集、差集）。</li></ul></li><li><p><strong>常用命令</strong>：</p><div class="language-bash line-numbers-mode" data-highlighter="prismjs" data-ext="sh" data-title="sh"><pre><code><span class="line">SADD key value      <span class="token comment"># 添加元素</span></span>
<span class="line">SREM key value      <span class="token comment"># 移除元素</span></span>
<span class="line">SMEMBERS key        <span class="token comment"># 获取所有元素</span></span>
<span class="line">SISMEMBER key value <span class="token comment"># 判断是否存在</span></span>
<span class="line">SUNION key1 key2    <span class="token comment"># 并集</span></span>
<span class="line">SINTER key1 key2    <span class="token comment"># 交集</span></span>
<span class="line">SDIFF key1 key2     <span class="token comment"># 差集</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li></ul><hr><h3 id="_4️⃣-hash-哈希表" tabindex="-1"><a class="header-anchor" href="#_4️⃣-hash-哈希表"><span>4️⃣ <strong>Hash（哈希表）</strong></span></a></h3><ul><li><p>键值对集合，适合存储对象。</p></li><li><p><strong>特点</strong>：</p><ul><li>一个 key 对应一个哈希表，可以存储多个 field-value 对。</li><li>查询单个 field 比查询整个对象更高效。</li></ul></li><li><p><strong>常用命令</strong>：</p><div class="language-bash line-numbers-mode" data-highlighter="prismjs" data-ext="sh" data-title="sh"><pre><code><span class="line">HSET key field value   <span class="token comment"># 设置字段值</span></span>
<span class="line">HGET key field         <span class="token comment"># 获取字段值</span></span>
<span class="line">HGETALL key            <span class="token comment"># 获取整个哈希表</span></span>
<span class="line">HDEL key field         <span class="token comment"># 删除字段</span></span>
<span class="line">HEXISTS key field      <span class="token comment"># 判断字段是否存在</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li></ul><hr><h3 id="_5️⃣-sorted-set-有序集合" tabindex="-1"><a class="header-anchor" href="#_5️⃣-sorted-set-有序集合"><span>5️⃣ <strong>Sorted Set（有序集合）</strong></span></a></h3><ul><li><p>带分数的有序集合，每个元素关联一个分数（score），底层是跳表 + 哈希表。</p></li><li><p><strong>特点</strong>：</p><ul><li>元素唯一，但可以根据分数排序。</li><li>常用于排行榜、带权重的数据。</li></ul></li><li><p><strong>常用命令</strong>：</p><div class="language-bash line-numbers-mode" data-highlighter="prismjs" data-ext="sh" data-title="sh"><pre><code><span class="line">ZADD key score member      <span class="token comment"># 添加元素</span></span>
<span class="line">ZREM key member            <span class="token comment"># 移除元素</span></span>
<span class="line">ZRANGE key <span class="token number">0</span> <span class="token parameter variable">-1</span> WITHSCORES <span class="token comment"># 按分数升序获取</span></span>
<span class="line">ZREVRANGE key <span class="token number">0</span> <span class="token parameter variable">-1</span> WITHSCORES <span class="token comment"># 降序获取</span></span>
<span class="line">ZSCORE key member          <span class="token comment"># 获取分数</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li></ul><hr><p>💡 <strong>总结</strong>：</p><table><thead><tr><th>类型</th><th>是否有序</th><th>是否允许重复</th><th>使用场景</th></tr></thead><tbody><tr><td>String</td><td>是</td><td>是</td><td>简单 KV、计数器</td></tr><tr><td>List</td><td>是</td><td>是</td><td>队列、栈、消息列表</td></tr><tr><td>Set</td><td>否</td><td>否</td><td>唯一集合、关系运算</td></tr><tr><td>Hash</td><td>否</td><td>是</td><td>存储对象、字段查询</td></tr><tr><td>Sorted Set</td><td>是</td><td>元素唯一</td><td>排行榜、带权重排序</td></tr></tbody></table><hr><h3 id="关于redis还有一个stream类型-这个可能在php框架下-如symfony7下使用的比较多-laravel下使用的是list结构-这里做一个详细介绍" tabindex="-1"><a class="header-anchor" href="#关于redis还有一个stream类型-这个可能在php框架下-如symfony7下使用的比较多-laravel下使用的是list结构-这里做一个详细介绍"><span>关于redis还有一个<code>stream</code>类型，这个可能在PHP框架下，如symfony7下使用的比较多, laravel下使用的是List结构，这里做一个详细介绍:</span></a></h3><h3 id="redis-stream-完整总结" tabindex="-1"><a class="header-anchor" href="#redis-stream-完整总结"><span><strong>Redis Stream 完整总结</strong></span></a></h3><h3 id="_1️⃣-概念" tabindex="-1"><a class="header-anchor" href="#_1️⃣-概念"><span>1️⃣ 概念</span></a></h3><ul><li><p><strong>Stream</strong> 是 Redis 5+ 引入的 <strong>日志型数据结构</strong></p></li><li><p><strong>消息日志</strong>：每条消息有唯一 ID（时间戳-序列号）</p></li><li><p><strong>特点</strong>：</p><ul><li>可追加消息，不会自动删除</li><li>按顺序存储</li><li>支持消费者组（多消费者共享、ACK机制）</li><li>可做消息队列、事件流、日志系统</li></ul></li></ul><hr><h3 id="_2️⃣-基本用法" tabindex="-1"><a class="header-anchor" href="#_2️⃣-基本用法"><span>2️⃣ 基本用法</span></a></h3><h3 id="添加消息" tabindex="-1"><a class="header-anchor" href="#添加消息"><span>添加消息</span></a></h3><div class="language-bash line-numbers-mode" data-highlighter="prismjs" data-ext="sh" data-title="sh"><pre><code><span class="line">XADD mystream * field1 value1 field2 value2</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><ul><li><code>*</code>：自动生成消息 ID</li><li>如果 Stream 不存在，Redis 会自动创建</li><li>field1 value1 field2 value2 表示消息包含 一个或多个字段-值对，但仍然算作同一条消息(其实就像一个数据库的一条数据，有 id field1 field2 field3 ..., 比如:XADD orders_stream * order_id 12345 user_id 6789 amount 100.5)</li><li>返回值为消息ID，如 1699584903017-0</li></ul><h3 id="查看消息-普通读取" tabindex="-1"><a class="header-anchor" href="#查看消息-普通读取"><span>查看消息（普通读取）</span></a></h3><div class="language-bash line-numbers-mode" data-highlighter="prismjs" data-ext="sh" data-title="sh"><pre><code><span class="line">XRANGE mystream - + COUNT <span class="token number">10</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><ul><li><code>-</code> → 起始 ID（最小）</li><li><code>+</code> → 结束 ID（最大）</li></ul><hr><h3 id="_3️⃣-消费者组-consumer-group" tabindex="-1"><a class="header-anchor" href="#_3️⃣-消费者组-consumer-group"><span>3️⃣ 消费者组（Consumer Group）</span></a></h3><h3 id="创建消费者组" tabindex="-1"><a class="header-anchor" href="#创建消费者组"><span>创建消费者组</span></a></h3><div class="language-bash line-numbers-mode" data-highlighter="prismjs" data-ext="sh" data-title="sh"><pre><code><span class="line">XGROUP CREATE mystream mygroup <span class="token number">0</span> MKSTREAM</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><ul><li><code>mygroup</code>：组名</li><li><code>0</code>：从最早消息开始消费</li><li><code>MKSTREAM</code>：如果 Stream 不存在，自动创建</li></ul><h3 id="消费消息" tabindex="-1"><a class="header-anchor" href="#消费消息"><span>消费消息</span></a></h3><div class="language-bash line-numbers-mode" data-highlighter="prismjs" data-ext="sh" data-title="sh"><pre><code><span class="line">XREADGROUP GROUP mygroup worker1 COUNT <span class="token number">2</span> STREAMS mystream <span class="token operator">&gt;</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><ul><li><code>worker1</code>：消费者名，可随意命名，但组内唯一</li><li>COUNT 控制每次拉取消息条数，与消息内部字段数量无关，消息条数 ≤ COUNT，消费者可以批量处理多条消息，提高吞吐量</li><li><code>&gt;</code>：只读取新消息（未被组内任何消费者消费的消息）</li><li>消费的消息进入 <strong>Pending Entries List (PEL)</strong></li><li>返回值结构如下</li></ul><ol><li>&quot;mystream&quot;</li><li><ol><li><ol><li>&quot;1699584903017-0&quot; ← 这里就是 message-id，用于后续XACK</li></ol></li></ol></li><li><ol><li>&quot;field1&quot;</li></ol></li><li>&quot;value1&quot;</li><li>&quot;field2&quot;</li><li>&quot;value2&quot;</li></ol><h3 id="消费确认-ack" tabindex="-1"><a class="header-anchor" href="#消费确认-ack"><span>消费确认（ACK）</span></a></h3><div class="language-bash line-numbers-mode" data-highlighter="prismjs" data-ext="sh" data-title="sh"><pre><code><span class="line">XACK mystream mygroup <span class="token number">1699584903017</span>-0</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><ul><li>从组内 PEL 移除已处理的消息</li><li><strong>消息仍在 Stream 中</strong></li></ul><hr><h3 id="_4️⃣-多消费者组、多消费者" tabindex="-1"><a class="header-anchor" href="#_4️⃣-多消费者组、多消费者"><span>4️⃣ 多消费者组、多消费者</span></a></h3><ul><li><strong>同一个 Stream</strong> 可以有 <strong>多个消费者组</strong>：</li></ul><div class="language-bash line-numbers-mode" data-highlighter="prismjs" data-ext="sh" data-title="sh"><pre><code><span class="line">XGROUP CREATE mystream mygroup <span class="token number">0</span></span>
<span class="line">XGROUP CREATE mystream mygroup2 <span class="token number">0</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><ul><li><strong>同一条消息</strong>可以被不同组消费</li><li><strong>组内每条消息</strong>只会被组内一个消费者处理</li><li>消费者名（worker）在组内必须唯一</li><li>支持多消费者并行处理，提高吞吐量</li></ul><h3 id="示例" tabindex="-1"><a class="header-anchor" href="#示例"><span>示例</span></a></h3><div class="language-text line-numbers-mode" data-highlighter="prismjs" data-ext="text" data-title="text"><pre><code><span class="line">Stream: mystream</span>
<span class="line"> ├─ 1001-0</span>
<span class="line"> ├─ 1002-0</span>
<span class="line"></span>
<span class="line">消费者组 mygroup</span>
<span class="line"> ├─ worker1 → 消费 1001-0</span>
<span class="line"> └─ worker2 → 消费 1002-0</span>
<span class="line"></span>
<span class="line">消费者组 mygroup2</span>
<span class="line"> ├─ workerA → 消费 1001-0</span>
<span class="line"> └─ workerB → 消费 1002-0</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><hr><h3 id="_5️⃣-特点总结" tabindex="-1"><a class="header-anchor" href="#_5️⃣-特点总结"><span>5️⃣ 特点总结</span></a></h3><ol><li><p><strong>消息不自动删除</strong>，需要 XTRIM 或 MAXLEN 限制长度</p></li><li><p><strong>消费是逻辑概念</strong>：</p><ul><li>ACK 只是标记组内消息已处理</li><li>不影响 Stream 中的原始消息</li></ul></li><li><p><strong>PEL (Pending Entries List)</strong>：</p><ul><li>每个消费者有自己的 PEL，未 ACK 消息可以重试</li></ul></li><li><p><strong>多组多消费者</strong>：</p><ul><li>不同组互不影响，实现广播/多订阅</li><li>组内多消费者共享组内消息，实现负载均衡</li></ul></li></ol><hr><p>💡 <strong>总结两句话</strong>： <strong>Stream 是日志型消息队列，消费者组提供逻辑消费机制，多组多消费者可并行处理且消息安全可靠。</strong><strong>Stream 本质就是一个 时间有序的事件表，消息生产、消费、ACK 的过程，逻辑上类似数据库的 插入、查询、更新。</strong></p>`,55)]))}const p=e(i,[["render",t],["__file","关于Redis的五大基本数据结构.html.vue"]]),c=JSON.parse('{"path":"/content/database/redis/%E5%85%B3%E4%BA%8ERedis%E7%9A%84%E4%BA%94%E5%A4%A7%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.html","title":"关于Redis的五大基本数据结构","lang":"en-US","frontmatter":{"sidebar":false,"title":"关于Redis的五大基本数据结构","head":[["meta",{"name":"title","content":"关于Redis的五大基本数据结构"}],["meta",{"name":"description","content":"关于Redis的五大基本数据结构"}],["meta",{"name":"keywords","content":"关于Redis的五大基本数据结构"}],["meta",{"property":"og:title","content":"关于Redis的五大基本数据结构"}],["meta",{"property":"og:description","content":"关于Redis的五大基本数据结构"}]]},"headers":[{"level":3,"title":"关于Redis的五大基本数据结构, Redis 是一个内存型键值数据库，它支持多种数据类型，常用的5个基本数据类型如下：","slug":"关于redis的五大基本数据结构-redis-是一个内存型键值数据库-它支持多种数据类型-常用的5个基本数据类型如下","link":"#关于redis的五大基本数据结构-redis-是一个内存型键值数据库-它支持多种数据类型-常用的5个基本数据类型如下","children":[]},{"level":3,"title":"1️⃣ String（字符串）","slug":"_1️⃣-string-字符串","link":"#_1️⃣-string-字符串","children":[]},{"level":3,"title":"2️⃣ List（列表）","slug":"_2️⃣-list-列表","link":"#_2️⃣-list-列表","children":[]},{"level":3,"title":"3️⃣ Set（集合）","slug":"_3️⃣-set-集合","link":"#_3️⃣-set-集合","children":[]},{"level":3,"title":"4️⃣ Hash（哈希表）","slug":"_4️⃣-hash-哈希表","link":"#_4️⃣-hash-哈希表","children":[]},{"level":3,"title":"5️⃣ Sorted Set（有序集合）","slug":"_5️⃣-sorted-set-有序集合","link":"#_5️⃣-sorted-set-有序集合","children":[]},{"level":3,"title":"关于redis还有一个stream类型，这个可能在PHP框架下，如symfony7下使用的比较多, laravel下使用的是List结构，这里做一个详细介绍:","slug":"关于redis还有一个stream类型-这个可能在php框架下-如symfony7下使用的比较多-laravel下使用的是list结构-这里做一个详细介绍","link":"#关于redis还有一个stream类型-这个可能在php框架下-如symfony7下使用的比较多-laravel下使用的是list结构-这里做一个详细介绍","children":[]},{"level":3,"title":"Redis Stream 完整总结","slug":"redis-stream-完整总结","link":"#redis-stream-完整总结","children":[]},{"level":3,"title":"1️⃣ 概念","slug":"_1️⃣-概念","link":"#_1️⃣-概念","children":[]},{"level":3,"title":"2️⃣ 基本用法","slug":"_2️⃣-基本用法","link":"#_2️⃣-基本用法","children":[]},{"level":3,"title":"添加消息","slug":"添加消息","link":"#添加消息","children":[]},{"level":3,"title":"查看消息（普通读取）","slug":"查看消息-普通读取","link":"#查看消息-普通读取","children":[]},{"level":3,"title":"3️⃣ 消费者组（Consumer Group）","slug":"_3️⃣-消费者组-consumer-group","link":"#_3️⃣-消费者组-consumer-group","children":[]},{"level":3,"title":"创建消费者组","slug":"创建消费者组","link":"#创建消费者组","children":[]},{"level":3,"title":"消费消息","slug":"消费消息","link":"#消费消息","children":[]},{"level":3,"title":"消费确认（ACK）","slug":"消费确认-ack","link":"#消费确认-ack","children":[]},{"level":3,"title":"4️⃣ 多消费者组、多消费者","slug":"_4️⃣-多消费者组、多消费者","link":"#_4️⃣-多消费者组、多消费者","children":[]},{"level":3,"title":"示例","slug":"示例","link":"#示例","children":[]},{"level":3,"title":"5️⃣ 特点总结","slug":"_5️⃣-特点总结","link":"#_5️⃣-特点总结","children":[]}],"git":{},"filePathRelative":"content/database/redis/关于Redis的五大基本数据结构.md"}');export{p as comp,c as data};
