import{_ as n,c as a,d as e,o as t}from"./app-CHrRue27.js";const p={};function l(i,s){return t(),a("div",null,s[0]||(s[0]=[e(`<h5 id="laravel12下基于redis的消息队列原理回顾" tabindex="-1"><a class="header-anchor" href="#laravel12下基于redis的消息队列原理回顾"><span>laravel12下基于redis的消息队列原理回顾</span></a></h5><h5 id="_1-命令参数含义" tabindex="-1"><a class="header-anchor" href="#_1-命令参数含义"><span>1. 命令参数含义</span></a></h5><ul><li><code>queue:work</code> 👉 启动一个 <strong>队列 Worker 进程</strong></li><li><code>redis</code> 👉 不是 <strong>queue 名称</strong>，而是 <strong>队列连接（connection）名称</strong></li></ul><p>Laravel 的队列配置在 <code>config/queue.php</code>，里面有 <code>connections</code>：</p><div class="language-php line-numbers-mode" data-highlighter="prismjs" data-ext="php" data-title="php"><pre><code><span class="line"><span class="token string single-quoted-string">&#39;connections&#39;</span> <span class="token operator">=&gt;</span> <span class="token punctuation">[</span></span>
<span class="line">    <span class="token string single-quoted-string">&#39;sync&#39;</span> <span class="token operator">=&gt;</span> <span class="token punctuation">[</span><span class="token operator">...</span><span class="token punctuation">]</span><span class="token punctuation">,</span></span>
<span class="line">    <span class="token string single-quoted-string">&#39;database&#39;</span> <span class="token operator">=&gt;</span> <span class="token punctuation">[</span><span class="token operator">...</span><span class="token punctuation">]</span><span class="token punctuation">,</span></span>
<span class="line">    <span class="token string single-quoted-string">&#39;redis&#39;</span> <span class="token operator">=&gt;</span> <span class="token punctuation">[</span>   <span class="token comment">// ← 这里就是 connection 名字</span></span>
<span class="line">        <span class="token string single-quoted-string">&#39;driver&#39;</span> <span class="token operator">=&gt;</span> <span class="token string single-quoted-string">&#39;redis&#39;</span><span class="token punctuation">,</span></span>
<span class="line">        <span class="token string single-quoted-string">&#39;connection&#39;</span> <span class="token operator">=&gt;</span> <span class="token string single-quoted-string">&#39;default&#39;</span><span class="token punctuation">,</span></span>
<span class="line">        <span class="token string single-quoted-string">&#39;queue&#39;</span> <span class="token operator">=&gt;</span> <span class="token function">env</span><span class="token punctuation">(</span><span class="token string single-quoted-string">&#39;REDIS_QUEUE&#39;</span><span class="token punctuation">,</span> <span class="token string single-quoted-string">&#39;default&#39;</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token comment">// 默认队列名叫 &quot;default&quot;</span></span>
<span class="line">        <span class="token string single-quoted-string">&#39;retry_after&#39;</span> <span class="token operator">=&gt;</span> <span class="token number">90</span><span class="token punctuation">,</span></span>
<span class="line">        <span class="token string single-quoted-string">&#39;block_for&#39;</span> <span class="token operator">=&gt;</span> <span class="token constant">null</span><span class="token punctuation">,</span></span>
<span class="line">    <span class="token punctuation">]</span><span class="token punctuation">,</span></span>
<span class="line"><span class="token punctuation">]</span><span class="token punctuation">,</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>所以你运行：</p><div class="language-bash line-numbers-mode" data-highlighter="prismjs" data-ext="sh" data-title="sh"><pre><code><span class="line">php artisan queue:work redis</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>表示：<strong>用 <code>redis</code> 这个 connection 去取任务</strong>。</p><p>如果你要指定队列名字（queue name），要额外传：</p><div class="language-bash line-numbers-mode" data-highlighter="prismjs" data-ext="sh" data-title="sh"><pre><code><span class="line">php artisan queue:work redis <span class="token parameter variable">--queue</span><span class="token operator">=</span>emails</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>这样就会消费 <code>emails</code> 队列，而不是默认的 <code>default</code>。</p><h5 id="_2-worker-的运行原理" tabindex="-1"><a class="header-anchor" href="#_2-worker-的运行原理"><span>2. Worker 的运行原理</span></a></h5><p><code>queue:work</code> 会启动一个常驻 PHP 进程，内部大致流程是：</p><ol><li>进入循环 → 不断向 Redis 里 <code>BLPOP</code>（阻塞式 pop） 队列 <ul><li>默认队列 key 格式：<code>queues:default</code></li><li>如果指定 <code>--queue=emails</code> → key 就是 <code>queues:emails</code></li></ul></li><li>拿到队列消息（就是被 <code>dispatch()</code> 序列化过的 Job 数据）</li><li>反序列化 Job → 调用 Job 的 <code>handle()</code> 方法</li><li>如果失败 → 重新入队（延迟），或者进入 <code>failed_jobs</code> 表 <strong>本质上就是一个常驻消费者进程，用 Redis 列表实现消息队列。</strong></li></ol><h5 id="_3-redis-中的存储形式" tabindex="-1"><a class="header-anchor" href="#_3-redis-中的存储形式"><span>3. Redis 中的存储形式</span></a></h5><p>当你派发 Job：</p><div class="language-php line-numbers-mode" data-highlighter="prismjs" data-ext="php" data-title="php"><pre><code><span class="line"><span class="token class-name static-context">SendEmailJob</span><span class="token operator">::</span><span class="token function">dispatch</span><span class="token punctuation">(</span><span class="token string single-quoted-string">&#39;test@example.com&#39;</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>Redis 里会多一条数据：</p><div class="language-bash line-numbers-mode" data-highlighter="prismjs" data-ext="sh" data-title="sh"><pre><code><span class="line">LPUSH queues:default <span class="token string">&quot;序列化后的 Job&quot;</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>Worker 消费时就是：</p><div class="language-bash line-numbers-mode" data-highlighter="prismjs" data-ext="sh" data-title="sh"><pre><code><span class="line">BRPOP queues:default</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>然后执行 Job。</p><p>✅ 总结：</p><ul><li><code>php artisan queue:work redis</code> 里的 <strong>redis = connection 名</strong>，不是 queue 名。</li><li>真正的 <strong>队列名（queue name）</strong> 默认是 <code>default</code>，可以用 <code>--queue=</code> 参数指定。如： php artisan queue:work redis --queue=emails</li><li>Worker 内部就是不断 <strong>BRPOP Redis 列表</strong>，取出 Job，执行 <code>handle()</code>。</li></ul><hr><h5 id="config-queue-php下关于-after-commit配置的使用-这个特性很有必要-貌似从larael9-x-就有了-实际上有时候确实需要数据库操作完成-才回去触发异步任务-这样的需求很多" tabindex="-1"><a class="header-anchor" href="#config-queue-php下关于-after-commit配置的使用-这个特性很有必要-貌似从larael9-x-就有了-实际上有时候确实需要数据库操作完成-才回去触发异步任务-这样的需求很多"><span>config/queue.php下关于 after_commit配置的使用，这个特性很有必要，貌似从larael9.x 就有了，实际上有时候确实需要数据库操作完成，才回去触发异步任务，这样的需求很多</span></a></h5><p>在 <strong>Laravel 12</strong> 的 <code>queue.php</code> 配置中，<code>after_commit</code> 是一个比较新的选项，用来控制 <strong>Job 是否在数据库事务提交后再入队</strong>。</p><h3 id="_1-默认配置示例" tabindex="-1"><a class="header-anchor" href="#_1-默认配置示例"><span>1. 默认配置示例</span></a></h3><div class="language-php line-numbers-mode" data-highlighter="prismjs" data-ext="php" data-title="php"><pre><code><span class="line"><span class="token string single-quoted-string">&#39;connections&#39;</span> <span class="token operator">=&gt;</span> <span class="token punctuation">[</span></span>
<span class="line">    <span class="token string single-quoted-string">&#39;database&#39;</span> <span class="token operator">=&gt;</span> <span class="token punctuation">[</span></span>
<span class="line">        <span class="token string single-quoted-string">&#39;driver&#39;</span> <span class="token operator">=&gt;</span> <span class="token string single-quoted-string">&#39;database&#39;</span><span class="token punctuation">,</span></span>
<span class="line">        <span class="token string single-quoted-string">&#39;table&#39;</span> <span class="token operator">=&gt;</span> <span class="token string single-quoted-string">&#39;jobs&#39;</span><span class="token punctuation">,</span></span>
<span class="line">        <span class="token string single-quoted-string">&#39;queue&#39;</span> <span class="token operator">=&gt;</span> <span class="token string single-quoted-string">&#39;default&#39;</span><span class="token punctuation">,</span></span>
<span class="line">        <span class="token string single-quoted-string">&#39;retry_after&#39;</span> <span class="token operator">=&gt;</span> <span class="token number">90</span><span class="token punctuation">,</span></span>
<span class="line">        <span class="token string single-quoted-string">&#39;after_commit&#39;</span> <span class="token operator">=&gt;</span> <span class="token constant boolean">false</span><span class="token punctuation">,</span></span>
<span class="line">    <span class="token punctuation">]</span><span class="token punctuation">,</span></span>
<span class="line">    <span class="token string single-quoted-string">&#39;redis&#39;</span> <span class="token operator">=&gt;</span> <span class="token punctuation">[</span></span>
<span class="line">        <span class="token string single-quoted-string">&#39;driver&#39;</span> <span class="token operator">=&gt;</span> <span class="token string single-quoted-string">&#39;redis&#39;</span><span class="token punctuation">,</span></span>
<span class="line">        <span class="token string single-quoted-string">&#39;connection&#39;</span> <span class="token operator">=&gt;</span> <span class="token string single-quoted-string">&#39;default&#39;</span><span class="token punctuation">,</span></span>
<span class="line">        <span class="token string single-quoted-string">&#39;queue&#39;</span> <span class="token operator">=&gt;</span> <span class="token function">env</span><span class="token punctuation">(</span><span class="token string single-quoted-string">&#39;REDIS_QUEUE&#39;</span><span class="token punctuation">,</span> <span class="token string single-quoted-string">&#39;default&#39;</span><span class="token punctuation">)</span><span class="token punctuation">,</span></span>
<span class="line">        <span class="token string single-quoted-string">&#39;retry_after&#39;</span> <span class="token operator">=&gt;</span> <span class="token number">90</span><span class="token punctuation">,</span></span>
<span class="line">        <span class="token string single-quoted-string">&#39;block_for&#39;</span> <span class="token operator">=&gt;</span> <span class="token constant">null</span><span class="token punctuation">,</span></span>
<span class="line">        <span class="token string single-quoted-string">&#39;after_commit&#39;</span> <span class="token operator">=&gt;</span> <span class="token constant boolean">false</span><span class="token punctuation">,</span></span>
<span class="line">    <span class="token punctuation">]</span><span class="token punctuation">,</span></span>
<span class="line"><span class="token punctuation">]</span><span class="token punctuation">,</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h5 id="_2-after-commit-的作用" tabindex="-1"><a class="header-anchor" href="#_2-after-commit-的作用"><span>2. <code>after_commit</code> 的作用</span></a></h5><ul><li><p><strong><code>after_commit = false</code>（默认）</strong></p><ul><li>Job 会立即入队，即使当前数据库事务尚未提交</li><li>如果事务回滚，Job 依然会被消费 → 可能导致业务逻辑异常</li></ul></li><li><p><strong><code>after_commit = true</code></strong></p><ul><li>Job 会 <strong>等到数据库事务提交成功后</strong> 再入队</li><li>保证 Job 消费时，相关数据库操作已经生效</li><li>常用于依赖数据库状态的异步任务，例如发送邮件、延迟计算统计等</li></ul></li></ul><h5 id="_3-使用示例" tabindex="-1"><a class="header-anchor" href="#_3-使用示例"><span>3. 使用示例</span></a></h5><div class="language-php line-numbers-mode" data-highlighter="prismjs" data-ext="php" data-title="php"><pre><code><span class="line"><span class="token keyword">use</span> <span class="token package">App<span class="token punctuation">\\</span>Jobs<span class="token punctuation">\\</span>MyJob</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token keyword">use</span> <span class="token package">Illuminate<span class="token punctuation">\\</span>Support<span class="token punctuation">\\</span>Facades<span class="token punctuation">\\</span>DB</span><span class="token punctuation">;</span></span>
<span class="line"></span>
<span class="line"><span class="token class-name static-context">DB</span><span class="token operator">::</span><span class="token function">transaction</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">use</span> <span class="token punctuation">(</span><span class="token variable">$user</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">    <span class="token variable">$user</span><span class="token operator">-&gt;</span><span class="token function">update</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token string single-quoted-string">&#39;status&#39;</span> <span class="token operator">=&gt;</span> <span class="token string single-quoted-string">&#39;active&#39;</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"></span>
<span class="line">    <span class="token comment">// Job 只有在事务提交成功后才会入队</span></span>
<span class="line">    <span class="token class-name static-context">MyJob</span><span class="token operator">::</span><span class="token function">dispatch</span><span class="token punctuation">(</span><span class="token variable">$user</span><span class="token punctuation">)</span><span class="token operator">-&gt;</span><span class="token function">afterCommit</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li><code>afterCommit()</code> 方法可以在 dispatch 时单独控制</li><li>配置文件 <code>after_commit</code> 选项是全局默认值</li></ul><h5 id="_4-总结" tabindex="-1"><a class="header-anchor" href="#_4-总结"><span>4. 总结</span></a></h5><table><thead><tr><th>配置 / 方法</th><th>行为</th></tr></thead><tbody><tr><td><code>after_commit = false</code></td><td>Job 立即入队，不依赖事务提交</td></tr><tr><td><code>after_commit = true</code></td><td>Job 只有在事务提交成功后入队</td></tr><tr><td><code>-&gt;afterCommit()</code> 方法</td><td>单次 dispatch 时覆盖全局配置</td></tr></tbody></table><p>✅ 小结：</p><ul><li>如果 Job 依赖数据库状态，<strong>推荐开启 <code>after_commit</code></strong> 或使用 <code>-&gt;afterCommit()</code></li><li>如果 Job 与事务无关，可以保持默认 <code>false</code></li></ul><hr><h5 id="使用延迟队列" tabindex="-1"><a class="header-anchor" href="#使用延迟队列"><span>使用延迟队列</span></a></h5><p>在 <strong>Laravel 12</strong> 下，如果你想让某个 Job <strong>延迟执行</strong>，可以用 <strong><code>delay()</code> 方法</strong> 或 <code>onQueue</code> + <code>delay</code> 的组合。这里详细讲一下：</p><h5 id="_1-在-dispatch-时指定延迟" tabindex="-1"><a class="header-anchor" href="#_1-在-dispatch-时指定延迟"><span>1. 在 Dispatch 时指定延迟</span></a></h5><div class="language-php line-numbers-mode" data-highlighter="prismjs" data-ext="php" data-title="php"><pre><code><span class="line"><span class="token keyword">use</span> <span class="token package">App<span class="token punctuation">\\</span>Jobs<span class="token punctuation">\\</span>MyJob</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token keyword">use</span> <span class="token package">Illuminate<span class="token punctuation">\\</span>Support<span class="token punctuation">\\</span>Facades<span class="token punctuation">\\</span>Bus</span><span class="token punctuation">;</span></span>
<span class="line"></span>
<span class="line"><span class="token comment">// 延迟 10 秒执行</span></span>
<span class="line"><span class="token class-name static-context">MyJob</span><span class="token operator">::</span><span class="token function">dispatch</span><span class="token punctuation">(</span><span class="token variable">$param1</span><span class="token punctuation">,</span> <span class="token variable">$param2</span><span class="token punctuation">)</span><span class="token operator">-&gt;</span><span class="token function">delay</span><span class="token punctuation">(</span><span class="token function">now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-&gt;</span><span class="token function">addSeconds</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li><code>now()</code> → 当前时间</li><li><code>addSeconds(10)</code> → 延迟 10 秒</li><li>也可以用 <code>addMinutes()</code>, <code>addHours()</code> 等</li></ul><h5 id="例子" tabindex="-1"><a class="header-anchor" href="#例子"><span>例子：</span></a></h5><div class="language-php line-numbers-mode" data-highlighter="prismjs" data-ext="php" data-title="php"><pre><code><span class="line"><span class="token class-name static-context">MyJob</span><span class="token operator">::</span><span class="token function">dispatch</span><span class="token punctuation">(</span><span class="token variable">$user</span><span class="token punctuation">)</span><span class="token operator">-&gt;</span><span class="token function">delay</span><span class="token punctuation">(</span><span class="token function">now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-&gt;</span><span class="token function">addMinutes</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><ul><li>Job 会被推到队列，但 <strong>不会立即被 worker 执行</strong></li><li>Worker 取到任务时会检查 <code>available_at</code> 时间，未到时会跳过</li></ul><h5 id="_2-在-job-类里使用-shouldqueue" tabindex="-1"><a class="header-anchor" href="#_2-在-job-类里使用-shouldqueue"><span>2. 在 Job 类里使用 <code>ShouldQueue</code></span></a></h5><p>确保你的 Job 类实现了 <code>ShouldQueue</code>：</p><div class="language-php line-numbers-mode" data-highlighter="prismjs" data-ext="php" data-title="php"><pre><code><span class="line"><span class="token keyword">use</span> <span class="token package">Illuminate<span class="token punctuation">\\</span>Bus<span class="token punctuation">\\</span>Queueable</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token keyword">use</span> <span class="token package">Illuminate<span class="token punctuation">\\</span>Contracts<span class="token punctuation">\\</span>Queue<span class="token punctuation">\\</span>ShouldQueue</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token keyword">use</span> <span class="token package">Illuminate<span class="token punctuation">\\</span>Foundation<span class="token punctuation">\\</span>Bus<span class="token punctuation">\\</span>Dispatchable</span><span class="token punctuation">;</span></span>
<span class="line"></span>
<span class="line"><span class="token keyword">class</span> <span class="token class-name-definition class-name">MyJob</span> <span class="token keyword">implements</span> <span class="token class-name">ShouldQueue</span></span>
<span class="line"><span class="token punctuation">{</span></span>
<span class="line">    <span class="token keyword">use</span> <span class="token package">Dispatchable</span><span class="token punctuation">,</span> Queueable<span class="token punctuation">;</span></span>
<span class="line"></span>
<span class="line">    <span class="token keyword">public</span> <span class="token keyword">function</span> <span class="token function-definition function">handle</span><span class="token punctuation">(</span><span class="token punctuation">)</span></span>
<span class="line">    <span class="token punctuation">{</span></span>
<span class="line">        <span class="token comment">// 任务逻辑</span></span>
<span class="line">    <span class="token punctuation">}</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li><code>Queueable</code> trait 提供了 <code>delay()</code> 方法的支持</li><li><code>ShouldQueue</code> 告诉 Laravel 这是一个异步任务</li></ul><h5 id="_3-结合队列名" tabindex="-1"><a class="header-anchor" href="#_3-结合队列名"><span>3. 结合队列名</span></a></h5><p>如果你有多个队列，也可以指定队列：</p><div class="language-php line-numbers-mode" data-highlighter="prismjs" data-ext="php" data-title="php"><pre><code><span class="line"><span class="token class-name static-context">MyJob</span><span class="token operator">::</span><span class="token function">dispatch</span><span class="token punctuation">(</span><span class="token variable">$user</span><span class="token punctuation">)</span></span>
<span class="line">    <span class="token operator">-&gt;</span><span class="token function">onQueue</span><span class="token punctuation">(</span><span class="token string single-quoted-string">&#39;emails&#39;</span><span class="token punctuation">)</span></span>
<span class="line">    <span class="token operator">-&gt;</span><span class="token function">delay</span><span class="token punctuation">(</span><span class="token function">now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-&gt;</span><span class="token function">addMinutes</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>Job 会被推到 <code>emails</code> 队列</li><li>Worker 可以专门监听 <code>emails</code> 队列</li></ul><h5 id="_4-延迟实现原理-redis-队列" tabindex="-1"><a class="header-anchor" href="#_4-延迟实现原理-redis-队列"><span>4. 延迟实现原理（Redis 队列）</span></a></h5><ul><li>Laravel 会把 Job 推到 <strong>Redis 的 <code>delayed</code> 队列</strong></li><li>Worker 会周期性检查任务的 <code>available_at</code> 时间</li><li>只有到达时间的 Job 才会从 <code>delayed</code> 队列移动到正常队列，等待消费</li></ul><blockquote><p>所以延迟执行是通过 <strong>Redis 队列 + 时间戳</strong> 控制的，不依赖 PHP sleep 或阻塞</p></blockquote><h5 id="_5-关于-延迟原理的详细分析" tabindex="-1"><a class="header-anchor" href="#_5-关于-延迟原理的详细分析"><span>5.关于 延迟原理的详细分析</span></a></h5><p>在 <strong>Laravel 队列 + Redis</strong> 的场景下，Worker 确实同时扮演了 <strong>两个角色</strong>：</p><ol><li><strong>消费者（Consumer）</strong></li></ol><ul><li>从主队列（ready queue）取任务执行</li><li>核心行为： <ul><li>监听队列（BLPOP 或轮询）</li><li>拿到任务 → 调用 Job 的 <code>handle()</code> 执行</li></ul></li><li>类似“真正的工人”，负责处理业务逻辑</li></ul><ol start="2"><li><strong>延迟任务搬运者（Delayed Job Scheduler）</strong></li></ol><ul><li>周期性检查 Redis <code>delayed</code> 队列</li><li>核心行为： <ul><li>取出到达 <code>available_at</code> 时间的 Job</li><li>把它移动到主队列（ready queue）</li></ul></li><li>类似“调度员”，保证延迟任务在到期时进入可执行队列</li></ul><ol start="3"><li>图示理解（逻辑流程）</li></ol><div class="language-text line-numbers-mode" data-highlighter="prismjs" data-ext="text" data-title="text"><pre><code><span class="line">Delayed Queue (Redis zset)</span>
<span class="line">       |</span>
<span class="line">       |  Worker 检查 available_at</span>
<span class="line">       v</span>
<span class="line">Ready Queue (Redis list)</span>
<span class="line">       |</span>
<span class="line">       |  Worker 消费任务</span>
<span class="line">       v</span>
<span class="line">Job handle() 执行</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>表格解析:</p><table><thead><tr><th>概念</th><th>说明</th></tr></thead><tbody><tr><td>Worker</td><td>运行 <code>php artisan queue:work</code> 的 CLI 进程</td></tr><tr><td>Delayed 队列</td><td>Redis 的 zset，score = available_at</td></tr><tr><td>周期检查</td><td>Worker 循环中调用 <code>migrateExpiredJobs()</code> 检查到期任务</td></tr><tr><td>Ready 队列</td><td>Job 到时间后被移入这个队列，等待执行</td></tr></tbody></table><ul><li>Worker 是 <strong>单个常驻进程</strong>，同时做 <strong>调度</strong> 和 <strong>消费</strong></li><li>所以即使延迟任务很多，也不需要额外的 Cron，Worker 自己就能处理</li></ul><p>✅ 总结</p><ul><li><strong>Worker = 消费者 + 延迟任务搬运者</strong></li><li>延迟任务逻辑是 Worker 内部循环的一部分</li><li>你可以通过启动多个 Worker 或指定队列，灵活管理消费策略</li></ul><p>✅ 总结：</p><ol><li>Job 类要 <code>implements ShouldQueue</code></li><li>Dispatch 时调用 <code>-&gt;delay(now()-&gt;addMinutes(...))</code></li><li>可选 <code>onQueue()</code> 指定队列</li><li>Worker 会自动处理延迟逻辑</li></ol><p>参考文档: https://laravel.com/docs/12.x/queues#delayed-dispatching</p><hr><h5 id="关于-多个不同的queue-name-的使用以及消费" tabindex="-1"><a class="header-anchor" href="#关于-多个不同的queue-name-的使用以及消费"><span>关于 多个不同的queue name 的使用以及消费</span></a></h5><h5 id="_1-多队列共享一个-redis-连接" tabindex="-1"><a class="header-anchor" href="#_1-多队列共享一个-redis-连接"><span>1. 多队列共享一个 Redis 连接</span></a></h5><ul><li><p><code>connection</code> 决定的是 <strong>Redis 实例/数据库</strong></p></li><li><p><code>queue name</code> 决定的是 <strong>逻辑队列分组</strong></p></li><li><p>所以你可以在同一个 Redis 里，有多个逻辑队列：</p><ul><li><code>default</code></li><li><code>emails</code></li><li><code>notifications</code></li></ul></li></ul><h5 id="_2-worker-消费方式" tabindex="-1"><a class="header-anchor" href="#_2-worker-消费方式"><span>2. Worker 消费方式</span></a></h5><h5 id="a-消费所有队列" tabindex="-1"><a class="header-anchor" href="#a-消费所有队列"><span>(a) 消费所有队列</span></a></h5><div class="language-bash line-numbers-mode" data-highlighter="prismjs" data-ext="sh" data-title="sh"><pre><code><span class="line">php artisan queue:work redis</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><ul><li>不指定 <code>--queue</code> → 默认会消费 <code>default</code> 队列</li><li>如果想消费多个队列，可以：</li></ul><div class="language-bash line-numbers-mode" data-highlighter="prismjs" data-ext="sh" data-title="sh"><pre><code><span class="line">php artisan queue:work redis <span class="token parameter variable">--queue</span><span class="token operator">=</span>default,emails,notifications</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><ul><li>Worker 会按顺序轮询这些队列的任务</li></ul><h5 id="b-为特定队列指定-supervisor" tabindex="-1"><a class="header-anchor" href="#b-为特定队列指定-supervisor"><span>(b) 为特定队列指定 Supervisor</span></a></h5><ul><li>假设你只想消费 <code>emails</code> 队列：</li></ul><div class="language-bash line-numbers-mode" data-highlighter="prismjs" data-ext="sh" data-title="sh"><pre><code><span class="line">php artisan queue:work redis <span class="token parameter variable">--queue</span><span class="token operator">=</span>emails</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><ul><li>然后配置 Supervisor 管理这个 worker：</li></ul><div class="language-ini line-numbers-mode" data-highlighter="prismjs" data-ext="ini" data-title="ini"><pre><code><span class="line"><span class="token section"><span class="token punctuation">[</span><span class="token section-name selector">program:laravel-emails</span><span class="token punctuation">]</span></span></span>
<span class="line"><span class="token key attr-name">command</span><span class="token punctuation">=</span><span class="token value attr-value">php /var/www/html/artisan queue:work redis --queue=emails --sleep=3 --tries=3</span></span>
<span class="line"><span class="token key attr-name">process_name</span><span class="token punctuation">=</span><span class="token value attr-value">%(program_name)s_%(process_num)02d</span></span>
<span class="line"><span class="token key attr-name">numprocs</span><span class="token punctuation">=</span><span class="token value attr-value">1</span></span>
<span class="line"><span class="token key attr-name">autostart</span><span class="token punctuation">=</span><span class="token value attr-value">true</span></span>
<span class="line"><span class="token key attr-name">autorestart</span><span class="token punctuation">=</span><span class="token value attr-value">true</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>这样就专门为 <code>emails</code> 队列单独管理 worker，避免其他队列任务影响它的消费速度</li></ul><h5 id="_3-总结" tabindex="-1"><a class="header-anchor" href="#_3-总结"><span>3. 总结</span></a></h5><table><thead><tr><th>概念</th><th>作用</th></tr></thead><tbody><tr><td>connection</td><td>Redis 实例/队列驱动，底层存储</td></tr><tr><td>queue name</td><td>逻辑队列分组，用于区分不同任务类型</td></tr><tr><td>Worker 不指定队列</td><td>默认消费默认队列，也可通过 <code>--queue=a,b,c</code> 轮询多个队列</td></tr><tr><td>Worker 指定队列</td><td>可以专门消费某个队列，用 Supervisor 单独管理性能/资源</td></tr></tbody></table><p>简单理解：</p><ul><li><strong>connection = Redis 后台仓库</strong></li><li><strong>queue name = Redis 仓库里的不同抽屉</strong></li><li><strong>Worker = 打开抽屉取任务的人</strong></li></ul><p>这样你就可以灵活地按业务拆分队列、单独管理资源。</p><hr><h5 id="关于redis的blpop" tabindex="-1"><a class="header-anchor" href="#关于redis的blpop"><span>关于redis的BLPOP</span></a></h5><p><code>BLPOP</code> 的名字就是 <strong>Blocking Left POP</strong>：</p><ul><li><strong>L = Left</strong> 👉 从列表（list）的左边（头部）取数据</li><li><strong>POP</strong> 👉 取出并删除该元素</li></ul><h3 id="举例" tabindex="-1"><a class="header-anchor" href="#举例"><span>举例：</span></a></h3><div class="language-bash line-numbers-mode" data-highlighter="prismjs" data-ext="sh" data-title="sh"><pre><code><span class="line">LPUSH myqueue <span class="token string">&quot;task1&quot;</span></span>
<span class="line">LPUSH myqueue <span class="token string">&quot;task2&quot;</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><p>现在队列内容是（左边是头部）：</p><div class="language-text line-numbers-mode" data-highlighter="prismjs" data-ext="text" data-title="text"><pre><code><span class="line">[&quot;task2&quot;, &quot;task1&quot;]</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>执行：</p><div class="language-bash line-numbers-mode" data-highlighter="prismjs" data-ext="sh" data-title="sh"><pre><code><span class="line">BLPOP myqueue <span class="token number">0</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>返回：</p><div class="language-text line-numbers-mode" data-highlighter="prismjs" data-ext="text" data-title="text"><pre><code><span class="line">1) &quot;myqueue&quot;</span>
<span class="line">2) &quot;task2&quot;</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><p>队列变为：</p><div class="language-text line-numbers-mode" data-highlighter="prismjs" data-ext="text" data-title="text"><pre><code><span class="line">[&quot;task1&quot;]</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>再执行一次：</p><div class="language-text line-numbers-mode" data-highlighter="prismjs" data-ext="text" data-title="text"><pre><code><span class="line">1) &quot;myqueue&quot;</span>
<span class="line">2) &quot;task1&quot;</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><p>队列变空。</p><h5 id="对比命令" tabindex="-1"><a class="header-anchor" href="#对比命令"><span>对比命令：</span></a></h5><ul><li><code>BLPOP</code> → 从左边取</li><li><code>BRPOP</code> → 从右边取</li></ul><hr><h5 id="queue-work-会启动一个常驻-php-进程-这个和php-fpm有关吗" tabindex="-1"><a class="header-anchor" href="#queue-work-会启动一个常驻-php-进程-这个和php-fpm有关吗"><span>queue:work 会启动一个常驻 PHP 进程 这个和php-fpm有关吗</span></a></h5><h5 id="_1-php-artisan-queue-work" tabindex="-1"><a class="header-anchor" href="#_1-php-artisan-queue-work"><span>1. <code>php artisan queue:work</code></span></a></h5><ul><li>启动的是一个 <strong>常驻的 PHP CLI 进程</strong>。</li><li>它直接跑在命令行（<code>php</code> 二进制）里，不依赖 Nginx/Apache。</li><li>原理是一个死循环：不断用 <code>BLPOP</code> 从 Redis 拉任务，然后执行 Job 的 <code>handle()</code>。</li><li>你可以用 <code>ps -ef | grep queue:work</code> 看到它就是一个普通的 <code>php</code> 进程。</li></ul><h5 id="_2-php-fpm" tabindex="-1"><a class="header-anchor" href="#_2-php-fpm"><span>2. <code>php-fpm</code></span></a></h5><ul><li><code>php-fpm</code>（FastCGI Process Manager）是 <strong>Web 请求的 PHP 进程池</strong>，通常由 Nginx/Apache 调用。</li><li>用来处理 <strong>HTTP 请求</strong>（比如你访问一个 Laravel 页面，Nginx 转发给 php-fpm）。</li><li><code>php-fpm</code> 的进程是短生命周期的：一个请求 → 执行 → 返回 → 等待下一个请求。</li></ul><h5 id="_3-两者的区别" tabindex="-1"><a class="header-anchor" href="#_3-两者的区别"><span>3. 两者的区别</span></a></h5><table><thead><tr><th>特性</th><th><code>queue:work</code></th><th><code>php-fpm</code></th></tr></thead><tbody><tr><td>启动方式</td><td>命令行 <code>php artisan queue:work</code></td><td>系统服务（<code>php-fpm</code>）</td></tr><tr><td>生命周期</td><td>常驻进程（死循环）</td><td>短请求生命周期</td></tr><tr><td>触发来源</td><td>Redis 队列任务</td><td>Nginx/Apache 发来的 HTTP 请求</td></tr><tr><td>场景</td><td>异步任务消费（发邮件、导出、通知等）</td><td>Web 页面请求处理</td></tr></tbody></table><h5 id="_4-有没有关系" tabindex="-1"><a class="header-anchor" href="#_4-有没有关系"><span>4. 有没有关系？</span></a></h5><ul><li><strong>运行环境</strong>：它们都用同一个 PHP 解释器（<code>php</code> 二进制 + PHP 扩展）。</li><li><strong>进程独立</strong>：<code>queue:work</code> 跟 <code>php-fpm</code> 没有直接关系，它们互不干扰。</li><li><strong>间接联系</strong>：Web 请求（php-fpm 执行）里 <code>dispatch()</code> 了一个 Job → Job 被推到 Redis → <code>queue:work</code> 消费并执行。</li></ul><p>所以可以理解为：</p><ul><li><strong>php-fpm 负责请求入口</strong></li><li><strong>queue:work 负责后台异步任务</strong> 它们是配套而不是相互依赖的。</li></ul><p>✅ 总结： <code>queue:work</code> 启动的常驻 PHP 进程 <strong>和 php-fpm 没关系</strong>，它就是一个独立的 PHP CLI worker。 唯一的联系是：Web 请求（php-fpm）可能会产生任务，交给 <code>queue:work</code> 去处理。</p><hr><h5 id="php-cli-和-php-fpm-在当前php-docker环境下的对比" tabindex="-1"><a class="header-anchor" href="#php-cli-和-php-fpm-在当前php-docker环境下的对比"><span>php cli 和 php fpm 在当前php docker环境下的对比</span></a></h5><p>本质上这两个都是 php 的 SAPI(Server API)</p><h5 id="php-v-i" tabindex="-1"><a class="header-anchor" href="#php-v-i"><span>$ php -v / -i</span></a></h5><p>PHP 8.3.0alpha1 (cli) (built: Jun 13 2023 11:11:54) (NTS) Copyright (c) The PHP Group Zend Engine v4.3.0-dev, Copyright (c) Zend Technologies</p><p>完美 ✅</p><p>这个输出说明你的 <strong>PHP CLI</strong> 已经可用：</p><ol><li><code>(cli)</code> → 告诉你这是 <strong>命令行接口（CLI）版本</strong></li><li><code>(NTS)</code> → 表示 <strong>非线程安全（Non Thread Safe）</strong></li><li>版本信息和 Zend Engine 都正常显示</li></ol><p>结合你之前的 <code>php-fpm -v</code> 输出：</p><table><thead><tr><th>组件</th><th>状态</th><th>作用</th></tr></thead><tbody><tr><td>php-cli</td><td>已安装</td><td>命令行运行 Artisan 命令、队列 Worker、Cron 等</td></tr><tr><td>php-fpm</td><td>已安装</td><td>Web 请求处理（通过 Nginx/Apache）</td></tr></tbody></table><h5 id="✅-总结" tabindex="-1"><a class="header-anchor" href="#✅-总结"><span>✅ 总结：</span></a></h5><ul><li><p>你的系统环境 <strong>完全可以</strong>：</p><ul><li>运行 <code>php artisan queue:work</code>（依赖 CLI）</li><li>处理 HTTP 请求（依赖 php-fpm）</li></ul></li><li><p>两者是独立的，互不影响，但可以配合使用：Web 请求产生任务 → CLI Worker 异步执行</p></li></ul><h5 id="php-fpm-v-i" tabindex="-1"><a class="header-anchor" href="#php-fpm-v-i"><span>$ php-fpm -v / -i</span></a></h5><p>PHP 8.3.0alpha1 (fpm-fcgi) (built: Jun 13 2023 11:11:57) Copyright (c) The PHP Group Zend Engine v4.3.0-dev, Copyright (c) Zend Technologies</p><p>完美 ✅</p><p>你的输出说明了几件事：</p><ol><li><p><strong>PHP-FPM 已安装</strong></p><ul><li><code>(fpm-fcgi)</code> 明确标识这是 <strong>FastCGI Process Manager</strong> 版本</li><li>可以被 Nginx/Apache 用来处理 Web 请求</li></ul></li><li><p><strong>PHP 版本</strong></p><ul><li>你安装的是 <strong>PHP 8.3.0 alpha1</strong>，属于开发版/测试版</li><li>注意生产环境最好用稳定版本</li></ul></li><li><p><strong>Zend Engine 版本</strong></p><ul><li>用于解释执行 PHP 代码的核心引擎信息</li></ul></li></ol><p>所以结论：</p><ul><li><strong>php-fpm 可用</strong> → 可以处理 Web 请求</li><li><strong>php-cli 依然独立</strong>，你的 <code>php -v</code> 输出 CLI 信息的话，也能跑命令行脚本和 <code>queue:work</code></li></ul><p>简单理解：</p><ul><li><strong>php-fpm</strong> → Web 请求入口</li><li><strong>php-cli</strong> → 命令行脚本、队列 Worker、Cron</li></ul><h5 id="查看不同server-api-加载的模块" tabindex="-1"><a class="header-anchor" href="#查看不同server-api-加载的模块"><span>查看不同Server API 加载的模块</span></a></h5><p>$ php -m</p><p>$ php-fpm -m</p><p>这两个命令输出的内容是一样的，为什么呢，按道理讲这是两个不同的SAPI环境，为什么会一样呢?</p><h5 id="_1-docker-镜像里的-php-结构" tabindex="-1"><a class="header-anchor" href="#_1-docker-镜像里的-php-结构"><span>1. Docker 镜像里的 PHP 结构</span></a></h5><ul><li>大多数官方 PHP 镜像（如 <code>php:8.3-fpm</code> 或 <code>php:8.3-cli</code>）本身包含 <strong>相同的核心和扩展目录</strong></li><li>Docker 安装扩展（<code>docker-php-ext-install</code> 或 <code>pecl install</code>）会把扩展统一安装到 <strong>PHP 的 extension_dir</strong> 下</li><li>无论你是 CLI 还是 FPM，都共享同一套扩展路径</li></ul><h5 id="_2-sapi-独立-但扩展共享" tabindex="-1"><a class="header-anchor" href="#_2-sapi-独立-但扩展共享"><span>2. SAPI 独立，但扩展共享</span></a></h5><ul><li><strong>SAPI</strong>：CLI 和 FPM 是不同的接口，行为不同</li><li><strong>扩展</strong>：安装在同一目录 → 都能被加载</li><li>所以即便 FPM 和 CLI 各自有自己的 <code>php.ini</code>，只要都启用相同扩展，就会看到几乎一样的 <code>php -m</code> / <code>php-fpm -m</code></li></ul><h5 id="_3-实际效果" tabindex="-1"><a class="header-anchor" href="#_3-实际效果"><span>3. 实际效果</span></a></h5><ul><li>CLI → 可以跑 <code>artisan queue:work</code>、Cron、命令行脚本</li><li>FPM → 处理 Web 请求</li><li>都能用 Redis、PDO、curl 等扩展</li><li>开发时不必担心扩展缺失</li></ul><p>✅ 总结：</p><ul><li><strong>Docker 安装的 PHP 扩展默认对 CLI 和 FPM 都可用</strong></li><li>CLI / FPM 的行为和配置仍然独立，只是扩展共享</li><li>所以看到 <code>php -m</code> 和 <code>php-fpm -m</code> 输出一致是正常现象</li></ul>`,160)]))}const c=n(p,[["render",l],["__file","laravel12下基于redis的消息队列原理回顾.html.vue"]]),r=JSON.parse('{"path":"/content/php/laravel/laravel12%E4%B8%8B%E5%9F%BA%E4%BA%8Eredis%E7%9A%84%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E5%8E%9F%E7%90%86%E5%9B%9E%E9%A1%BE.html","title":"laravel12下基于redis的消息队列原理回顾","lang":"en-US","frontmatter":{"sidebar":false,"title":"laravel12下基于redis的消息队列原理回顾","head":[["meta",{"name":"title","content":"laravel12下基于redis的消息队列原理回顾"}],["meta",{"name":"description","content":"laravel12下基于redis的消息队列原理回顾"}],["meta",{"name":"keywords","content":"laravel,php"}],["meta",{"property":"og:title","content":"laravel12下基于redis的消息队列原理回顾"}],["meta",{"property":"og:description","content":"laravel12下基于redis的消息队列原理回顾"}]]},"headers":[{"level":3,"title":"1. 默认配置示例","slug":"_1-默认配置示例","link":"#_1-默认配置示例","children":[]},{"level":3,"title":"举例：","slug":"举例","link":"#举例","children":[]}],"git":{},"filePathRelative":"content/php/laravel/laravel12下基于redis的消息队列原理回顾.md"}');export{c as comp,r as data};
