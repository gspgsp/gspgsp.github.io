import{_ as t,c as s,d as l,o as n}from"./app-CHrRue27.js";const o={};function i(a,e){return n(),s("div",null,e[0]||(e[0]=[l(`<h3 id="关于socket" tabindex="-1"><a class="header-anchor" href="#关于socket"><span>关于socket</span></a></h3><h4 id="_1-socket-本身是什么" tabindex="-1"><a class="header-anchor" href="#_1-socket-本身是什么"><span>1. Socket 本身是什么？</span></a></h4><ul><li><p><strong>Socket 不是协议</strong>，而是一种 <strong>编程接口（API）</strong>，提供应用程序和网络协议栈交互的接口。</p></li><li><p>作用：让应用程序可以发送/接收数据，而不用关心底层的传输细节。</p></li><li><p>常用类型：</p><ol><li><strong>TCP Socket</strong> → 面向连接、可靠传输</li><li><strong>UDP Socket</strong> → 无连接、快速传输</li></ol></li></ul><h4 id="_2-socket-与应用层协议的关系" tabindex="-1"><a class="header-anchor" href="#_2-socket-与应用层协议的关系"><span>2. Socket 与应用层协议的关系</span></a></h4><ul><li><p><strong>Socket 是载体</strong>，可以承载不同应用层协议：</p><ul><li>HTTP（浏览器请求）</li><li>WebSocket（实时消息）</li><li>MySQL 协议（数据库访问）</li><li>自定义二进制协议（游戏、IoT）</li></ul></li><li><p><strong>所以 Socket 本身不是应用层协议</strong>，只是应用层协议和传输层之间的桥梁。</p></li></ul><h4 id="_3-socket-的传输层依赖" tabindex="-1"><a class="header-anchor" href="#_3-socket-的传输层依赖"><span>3. Socket 的传输层依赖</span></a></h4><ul><li><p><strong>TCP Socket</strong> → 基于 <strong>TCP</strong> 传输层</p><ul><li>保证数据可靠、有序、完整</li><li>三次握手、四次挥手</li></ul></li><li><p><strong>UDP Socket</strong> → 基于 <strong>UDP</strong> 传输层</p><ul><li>无连接、不保证可靠性</li><li>适合实时性高、允许丢包的场景</li></ul></li><li><p>也就是说，<strong>Socket 的“底层”就是 TCP 或 UDP</strong>，而应用程序通过 Socket 使用它们。</p></li></ul><h4 id="_4-举例说明" tabindex="-1"><a class="header-anchor" href="#_4-举例说明"><span>4. 举例说明</span></a></h4><table><thead><tr><th>应用层协议 / 场景</th><th>Socket 类型</th><th>传输层协议</th></tr></thead><tbody><tr><td>HTTP/HTTPS</td><td>TCP Socket</td><td>TCP</td></tr><tr><td>WebSocket</td><td>TCP Socket</td><td>TCP</td></tr><tr><td>MySQL 客户端</td><td>TCP Socket</td><td>TCP</td></tr><tr><td>游戏实时数据</td><td>UDP Socket</td><td>UDP</td></tr><tr><td>DNS 查询</td><td>UDP Socket</td><td>UDP</td></tr></tbody></table><hr><h4 id="✅-总结" tabindex="-1"><a class="header-anchor" href="#✅-总结"><span>✅ 总结</span></a></h4><ol><li><strong>Socket 不是协议</strong>，是应用程序访问网络的接口。它不管底层是 TCP 还是 UDP，都是应用程序和网络协议栈之间的桥梁。</li><li><strong>Socket 可以承载不同应用层协议</strong>（HTTP、WebSocket、MySQL、自定义协议等）。</li><li><strong>底层传输依赖 TCP 或 UDP</strong>，决定数据可靠性和实时性。</li></ol><hr><h3 id="之所以有这个-socket-问题是因为-过去总是说socket协议-其实不对-应该是websocket协议" tabindex="-1"><a class="header-anchor" href="#之所以有这个-socket-问题是因为-过去总是说socket协议-其实不对-应该是websocket协议"><span>之所以有这个 <strong>socket</strong> 问题是因为，过去总是说socket协议，其实不对，应该是WebSocket协议</span></a></h3><p>很多人把 <strong>WebSocket</strong> 当成“Socket”，或者说“TCP 连接”，其实要区分清楚：</p><h4 id="_1-websocket-是应用层协议" tabindex="-1"><a class="header-anchor" href="#_1-websocket-是应用层协议"><span>1. WebSocket 是应用层协议</span></a></h4><ul><li><p><strong>WebSocket</strong> 定义了浏览器/客户端和服务器之间 <strong>双向通信的应用层协议</strong></p></li><li><p>它规定了：</p><ul><li>握手过程（HTTP Upgrade 请求）</li><li>数据帧格式（文本帧、二进制帧、Ping/Pong）</li><li>心跳和关闭流程</li></ul></li><li><p>也就是说，<strong>WebSocket 的语义、数据解析、帧边界</strong> 都属于应用层的东西。</p></li></ul><h4 id="_2-websocket-和-tcp-的关系" tabindex="-1"><a class="header-anchor" href="#_2-websocket-和-tcp-的关系"><span>2. WebSocket 和 TCP 的关系</span></a></h4><ul><li><p>WebSocket 并不是独立的传输协议，它是 <strong>运行在 TCP 之上的应用层协议</strong></p></li><li><p>TCP 提供：</p><ul><li>可靠传输</li><li>有序、完整、重传</li></ul></li><li><p>WebSocket 只关心 <strong>消息的格式、双向通信语义</strong>，不关心数据包是否丢失或乱序</p></li></ul><h4 id="_3-连接示意" tabindex="-1"><a class="header-anchor" href="#_3-连接示意"><span>3. 连接示意</span></a></h4><div class="language-text line-numbers-mode" data-highlighter="prismjs" data-ext="text" data-title="text"><pre><code><span class="line">客户端应用（浏览器/JS）</span>
<span class="line">        │</span>
<span class="line">   WebSocket 协议（应用层）</span>
<span class="line">        │</span>
<span class="line">   TCP Socket（传输层）</span>
<span class="line">        │</span>
<span class="line">       IP/网络层</span>
<span class="line">        │</span>
<span class="line">   数据链路/物理层</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>TCP Socket = 应用程序调用接口</li><li>TCP = 传输层协议，保证可靠传输</li><li>WebSocket = 应用层协议，定义消息格式和通信语义</li></ul><hr><h4 id="✅-总结-1" tabindex="-1"><a class="header-anchor" href="#✅-总结-1"><span>✅ 总结</span></a></h4><ul><li><strong>WebSocket ≠ TCP</strong></li><li><strong>WebSocket 是应用层协议</strong>，依赖 TCP 提供底层可靠传输</li><li>“WebSocket 连接”这个说法，只是习惯说法，本质上是 <strong>TCP 连接 + WebSocket 协议握手 + 双向数据流</strong></li></ul><hr><h3 id="案例-基于socket-js的实时监听响应" tabindex="-1"><a class="header-anchor" href="#案例-基于socket-js的实时监听响应"><span>案例:基于Socket.js的实时监听响应</span></a></h3><p><strong>实时监听响应</strong>，就是客户端和服务器 <strong>建立一个长连接</strong>，然后服务器可以主动推送数据给客户端，这正是 <strong>Socket.js/WebSocket</strong> 的用途。</p><h4 id="_1-核心原理" tabindex="-1"><a class="header-anchor" href="#_1-核心原理"><span>1. 核心原理</span></a></h4><ul><li><p><strong>传统 HTTP</strong></p><ul><li>客户端发请求 → 服务器响应 → 连接关闭</li><li>不适合实时通知，因为每次都要建立 TCP 连接，延迟高</li></ul></li><li><p><strong>Socket.js / WebSocket</strong></p><ul><li>客户端发一次握手请求（HTTP Upgrade） → 建立 TCP 长连接</li><li>服务器可以随时向客户端推送消息</li><li>双向通信、实时性高</li><li>底层仍然是 <strong>TCP Socket</strong>，WebSocket 协议在上面定义了消息格式</li></ul></li></ul><h4 id="_2-实时监听流程示意" tabindex="-1"><a class="header-anchor" href="#_2-实时监听流程示意"><span>2. 实时监听流程示意</span></a></h4><ol><li>客户端用 <code>socket.js</code> 发起连接请求</li><li>服务端接收，完成 WebSocket 握手</li><li>TCP 长连接建立</li><li>服务端可以 <strong>随时向客户端发送消息</strong>（例如聊天、通知、数据更新）</li><li>客户端监听 <code>onmessage</code> 回调，实时获取数据</li></ol><hr><h4 id="_3-总结" tabindex="-1"><a class="header-anchor" href="#_3-总结"><span>3. 总结</span></a></h4><ul><li><strong>socket.js / WebSocket</strong> = 应用层协议和 API</li><li><strong>TCP Socket</strong> = 底层传输保证可靠</li><li><strong>实时监听响应</strong> = 利用 WebSocket 在 TCP 长连接上实现的双向实时通信</li></ul>`,35)]))}const r=t(o,[["render",i],["__file","关于socket.html.vue"]]),d=JSON.parse('{"path":"/content/other/spread/%E5%85%B3%E4%BA%8Esocket.html","title":"关于socket","lang":"en-US","frontmatter":{"sidebar":false,"title":"关于socket","head":[["meta",{"name":"title","content":"关于socket"}],["meta",{"name":"description","content":"关于socket"}],["meta",{"name":"keywords","content":"socket"}],["meta",{"property":"og:title","content":"关于socket"}],["meta",{"property":"og:description","content":"关于socket"}]]},"headers":[{"level":3,"title":"关于socket","slug":"关于socket","link":"#关于socket","children":[]},{"level":3,"title":"之所以有这个 socket 问题是因为，过去总是说socket协议，其实不对，应该是WebSocket协议","slug":"之所以有这个-socket-问题是因为-过去总是说socket协议-其实不对-应该是websocket协议","link":"#之所以有这个-socket-问题是因为-过去总是说socket协议-其实不对-应该是websocket协议","children":[]},{"level":3,"title":"案例:基于Socket.js的实时监听响应","slug":"案例-基于socket-js的实时监听响应","link":"#案例-基于socket-js的实时监听响应","children":[]}],"git":{},"filePathRelative":"content/other/spread/关于socket.md"}');export{r as comp,d as data};
