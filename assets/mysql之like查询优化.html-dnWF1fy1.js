import{_ as e,c as r,d as a,o as n}from"./app-CHrRue27.js";const i={};function l(s,t){return n(),r("div",null,t[0]||(t[0]=[a('<p>mysql之like查询优化:<br> 最近写项目的时候，有跨表做 like 查询的操作，主表大概有十万条数据 副表大概有 四十万的数据，差不多 1:4的关系，表结构如下： t_products</p><table><thead><tr><th style="text-align:left;">字段名</th><th style="text-align:left;">类型</th><th>说明</th></tr></thead><tbody><tr><td style="text-align:left;">id</td><td style="text-align:left;">int</td><td>ID</td></tr><tr><td style="text-align:left;">name</td><td style="text-align:left;">string</td><td>名称</td></tr></tbody></table><p>t_product_attributes</p><table><thead><tr><th style="text-align:left;">字段名</th><th style="text-align:left;">类型</th><th>说明</th></tr></thead><tbody><tr><td style="text-align:left;">id</td><td style="text-align:left;">int</td><td>ID</td></tr><tr><td style="text-align:left;">product_id</td><td style="text-align:left;">int</td><td>产品ID</td></tr><tr><td style="text-align:left;">attribute</td><td style="text-align:left;">string</td><td>属性</td></tr></tbody></table><p>我用的laravel框架， 第一次直接 whereHas 通过 like 查询，结果 接口直接超时，报nginx 504，这是标准的 nginx 后端响应超时问题，所以想着不跨表查询，于是在 t_products 表 加了个字段 properties (text类型)，准备把副表中的属性全部用逗号追加起来，然后这样操作以后做like查询，果真要快很多，至少不会报超时问题，但是通过 explain 检查以后发现， type 为 All 查询，也就意味着要全表扫描，这样肯定不行，所以还是想用索引，最后想到用 全文索引(FullText)</p><p>通过如下命令给表添加全文索引:<br> ALTER TABLE t_products ADD FULLTEXT INDEX t_products (properties) with parser ngram;</p><p>查询：<br> ①原生 select * from t_products where (match(properties) against(&#39;蓝色&#39;)) and name like &#39;%手机%&#39;;<br> ②对于laravel框架，需要whereRaw操作： if (isset($params[&#39;attribute&#39;])) { $query = $query-&gt;whereRaw(&quot;match(properties) against(&#39;&quot;.$params[&#39;attribute&#39;].&quot;&#39;)&quot;); }</p><p>通过explain 检查发现 type 为 fulltext，证明用到了full-text-index，响应时间也更快</p><p>关于全文索引(FULLTEXT indexes):<br> FULLTEXT索引仅支持 InnoDB和 MyISAM表，并且只能包含 CHAR、 VARCHAR和 TEXT列。索引总是发生在整个列上；不支持列前缀索引，如果指定，任何前缀长度都将被忽略。 在MySQL 5.6版本以前,只有MyISAM存储引擎支持全文引擎， 在5.6版本中,InnoDB加入了对全文索引的支持,但是不支持中文全文索引， 在5.7.6版本,MySQL内置了ngram全文解析器,用来支持亚洲语种的分词，并且对MyISAM和InnoDB引擎有效。</p><p>在使用前请确认自己的mysql版本, 可以使用 select version() 查看mysql的版本。</p><p>在命令行执行：<br> show VARIABLES like &#39;%innodb_ft_%&#39;;</p><p>Variable_name Value innodb_ft_aux_table // 设置调式表 <br> innodb_ft_cache_size 8000000 //定义每个表的全文索引内存大小 <br> innodb_ft_enable_diag_print OFF <br> innodb_ft_enable_stopword ON //是否允许使用停止词 <br> innodb_ft_max_token_size 84 //默认84，表示最大84个字符作为一个关键词，限制该值可减少全文索引的大小 <br> innodb_ft_min_token_size 3 //默认3，表示最小3个字符作为一个关键词，增大该值可减少全文索引的大小 <br> innodb_ft_num_word_optimize 2000 <br> innodb_ft_result_cache_limit 2000000000 <br> innodb_ft_server_stopword_table <br> innodb_ft_sort_pll_degree 2 <br> innodb_ft_total_cache_size 640000000 //定义所有表的全文索引内存大小 <br> innodb_ft_user_stopword_table //定义的停止表，默认为 information_schema.INNODB_FT_DEFAULT_STOPWORD ，可以select * from information_schema.INNODB_FT_DEFAULT_STOPWORD,查看所有的停止词 <br></p><p>可以根据实际情况调大 innodb_ft_result_cache_limit 的值</p><p>对于innodDb存储引擎，要使用全文索引就必须用到如下格式(需要加 with parser ngram 参数)的命令创建索引： ALTER TABLE t_products ADD FULLTEXT INDEX t_products (properties) with parser ngram;</p><p>关于 ngram：<br> 在全文索引中，n-gram就是一段文字里面连续的n个字的序列，当使用 ngram 分词解析器以后，innodb_ft_min_token_size和innodb_ft_max_token_size 无效</p><p>关于全文索引模式：<br> 全文索引主要包括 自然语言模式 IN NATURAL LANGUAGE MODE(默认模式，可以不写) 和布尔模式 IN BOOLEAN MODE 其中boolean模式中,</p><p>“+”表示必须包含<br> “-”表示必须排除<br> “&gt;”表示出现该单词时增加相关性<br> “&lt;”表示出现该单词时降低相关性<br> “*”表示通配符<br> “~”允许出现该单词，但是出现时相关性为负<br> “&quot;&quot;”表示短语 //该模式下 和 IN NATURAL LANGUAGE MODE 类似<br></p><p>还有一种是：WITH QUERY EXPANSION 这个模式没用过 这种模式的查询分为两个阶段： 第一阶段：根据搜索的单词进行全文索引查询。 第二阶段：根据第一阶段产生的分词再进行一次全文检索的查询</p><p>模式使用：<br> 直接在against()参数后空格连接即可</p><p>比如上面的查询可以改为： if (isset($params[&#39;attribute&#39;])) { $query = $query-&gt;whereRaw(&#39;match(properties) against(&quot;&#39;.$params[&#39;attribute&#39;].&#39;&quot; IN BOOLEAN MODE)&#39;); }</p><p>注意：<br> 在使用过程中发现，如果 against 里只有一个字，那么可能查不到结果，原因是： 默认的 ngram_token_size 大小为2，这个值定义了分词的大小，这个值可以在 mysql的配置文件里，[mysqld]下重新配置,分词的SIZE越小，索引的体积就越大，所以要根据自身情况来设置合适的大小。 通过 show variables like &#39;%ngram%&#39;; 可以查看默认值为2</p><p>通过select match against 来计算全文索引相关性：<br> select id as &#39;数据ID&#39;, match(properties) against (&#39;红色&#39;) as &#39;全文索引相关性&#39; from t_products where (match(properties) against(&#39;红色&#39;)) and name like &#39;%手机%&#39;;</p><p>关于停止词表：<br> SET GLOBAL innodb_ft_user_stopword_table = &quot;test/my_innodb_ft_stopword&quot;; //test为数据库，my_innodb_ft_stopword 为test库下的表，虽然执行成功但是通过：show VARIABLES like &#39;%innodb_ft_%&#39;; 查看还是没有值 select * from information_schema.innodb_ft_index_table;</p>',23)]))}const _=e(i,[["render",l],["__file","mysql之like查询优化.html.vue"]]),d=JSON.parse('{"path":"/content/database/mysql/mysql%E4%B9%8Blike%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96.html","title":"mysql之like查询优化","lang":"en-US","frontmatter":{"sidebar":false,"title":"mysql之like查询优化","description":"mysql之like查询优化"},"headers":[],"git":{},"filePathRelative":"content/database/mysql/mysql之like查询优化.md"}');export{_ as comp,d as data};
