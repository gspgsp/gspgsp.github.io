import{_ as s,c as n,d as a,o as l}from"./app-CHrRue27.js";const i={};function t(r,e){return l(),n("div",null,e[0]||(e[0]=[a(`<h3 id="git之pull报错问题" tabindex="-1"><a class="header-anchor" href="#git之pull报错问题"><span>git之pull报错问题</span></a></h3><ul><li>1.今天在做code review的时候，发现个问题，开发修改了代码，然后我拉取的时候一直报: <ul><li><p>hint: You have divergent branches and need to specify how to reconcile them. hint: You can do so by running one of the following commands sometime before hint: your next pull: hint: hint: git config pull.rebase false # merge (the default strategy) hint: git config pull.rebase true # rebase hint: git config pull.ff only # fast-forward only hint: hint: You can replace &quot;git config&quot; with &quot;git config --global&quot; to set a default hint: preference for all repositories. You can also pass --rebase, --no-rebase, hint: or --ff-only on the command line to override the configured default per hint: invocation. Need to specify how to reconcile divergent branches.</p></li><li><p>这个很奇怪，我本地没有任何修改，怎么就报这个呢，后来才知道，我之前做过一次git pull(习惯性pull一下最新代码)，但是Git 可能在后台帮我生成了一个 merge commit（未提交状态）。 所以现在本地分支比远程“多了一个提交”，哪怕自己没改代码。 这个报错是因为在 <code>git pull</code> 的时候，本地分支和远程分支产生了 <strong>分歧 (divergent branches)</strong>，Git 不知道是想用 <strong>merge</strong>、<strong>rebase</strong> 还是只允许 <strong>fast-forward</strong>。</p></li><li><p>通过如下命令可以查看本地状态：</p><div class="language-text line-numbers-mode" data-highlighter="prismjs" data-ext="text" data-title="text"><pre><code><span class="line">git status</span>
<span class="line">git log --oneline --graph --decorate -n 10</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div></li></ul></li></ul><h4 id="报错信息已经给出了三种解决方式" tabindex="-1"><a class="header-anchor" href="#报错信息已经给出了三种解决方式"><span>报错信息已经给出了三种解决方式：</span></a></h4><h5 id="_1-直接指定一次性解决方式" tabindex="-1"><a class="header-anchor" href="#_1-直接指定一次性解决方式"><span>1. <strong>直接指定一次性解决方式</strong></span></a></h5><ul><li><p><strong>合并 (merge, 默认行为)：</strong></p><div class="language-bash line-numbers-mode" data-highlighter="prismjs" data-ext="sh" data-title="sh"><pre><code><span class="line"><span class="token function">git</span> pull --no-rebase</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>会生成一个 merge commit。</p></li><li><p><strong>变基 (rebase)：</strong></p><div class="language-bash line-numbers-mode" data-highlighter="prismjs" data-ext="sh" data-title="sh"><pre><code><span class="line"><span class="token function">git</span> pull <span class="token parameter variable">--rebase</span> //我使用这种方式解决问题,非常有用</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>会把本地提交“放到”远程提交之后，保持提交线性。</p></li><li><p><strong>只允许快进 (fast-forward only)：</strong></p><div class="language-bash line-numbers-mode" data-highlighter="prismjs" data-ext="sh" data-title="sh"><pre><code><span class="line"><span class="token function">git</span> pull --ff-only</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>如果不能直接快进，就会报错，不会自动合并。</p></li></ul><h4 id="_2-永久修改配置" tabindex="-1"><a class="header-anchor" href="#_2-永久修改配置"><span>2. <strong>永久修改配置</strong></span></a></h4><p>如果想以后都用某种策略，可以设置 <code>git config</code>：</p><ul><li><p>所有仓库都生效（推荐，除非某仓库有特殊需求）：</p><div class="language-bash line-numbers-mode" data-highlighter="prismjs" data-ext="sh" data-title="sh"><pre><code><span class="line"><span class="token function">git</span> config <span class="token parameter variable">--global</span> pull.rebase <span class="token boolean">false</span>   <span class="token comment"># 默认 merge</span></span>
<span class="line"><span class="token function">git</span> config <span class="token parameter variable">--global</span> pull.rebase <span class="token boolean">true</span>    <span class="token comment"># 默认 rebase</span></span>
<span class="line"><span class="token function">git</span> config <span class="token parameter variable">--global</span> pull.ff only        <span class="token comment"># 只允许 fast-forward</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li><li><p>只对当前仓库生效：</p><div class="language-bash line-numbers-mode" data-highlighter="prismjs" data-ext="sh" data-title="sh"><pre><code><span class="line"><span class="token function">git</span> config pull.rebase <span class="token boolean">true</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div></li></ul><hr><h3 id="git-pull-no-rebase-和-rebase的区别" tabindex="-1"><a class="header-anchor" href="#git-pull-no-rebase-和-rebase的区别"><span><code>git pull --no-rebase 和 --rebase的区别</code>:</span></a></h3><p>这两个参数就是 Git 在遇到“本地有提交 + 远程也有提交”时，如何把两边历史<strong>对齐</strong>的两种方式：</p><h4 id="_1-git-pull-no-rebase-默认行为-merge" tabindex="-1"><a class="header-anchor" href="#_1-git-pull-no-rebase-默认行为-merge"><span>1. <code>git pull --no-rebase</code> （默认行为：<strong>merge</strong>）</span></a></h4><ul><li><strong>做法</strong>：先 <code>git fetch</code>，然后把远程分支合并进来，生成一个新的 <strong>merge commit</strong>。</li><li><strong>结果</strong>： <ul><li>提交历史可能出现分叉。</li><li>会多一个 “Merge branch &#39;xxx&#39; of origin/xxx” 的提交。</li></ul></li><li><strong>优点</strong>： <ul><li>历史完整，能看出谁在什么时候合并了远程代码。</li></ul></li><li><strong>缺点</strong>： <ul><li>历史不够线性，可能很多 merge commit，看起来杂乱。</li></ul></li></ul><p>📌 举个例子：</p><div class="language-text line-numbers-mode" data-highlighter="prismjs" data-ext="text" data-title="text"><pre><code><span class="line">A---B---C (你的本地提交)</span>
<span class="line">     \\</span>
<span class="line">      D---E (远程提交)</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>执行 <code>git pull --no-rebase</code> 后：</p><div class="language-text line-numbers-mode" data-highlighter="prismjs" data-ext="text" data-title="text"><pre><code><span class="line">A---B---C---M (merge commit)</span>
<span class="line">     \\     /</span>
<span class="line">      D---E</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="_2-git-pull-rebase-历史线性化-rebase" tabindex="-1"><a class="header-anchor" href="#_2-git-pull-rebase-历史线性化-rebase"><span>2. <code>git pull --rebase</code> （历史线性化：<strong>rebase</strong>）</span></a></h4><ul><li><strong>做法</strong>：先 <code>git fetch</code>，然后把你本地的提交“拿掉”，把远程的提交放进来，再把你的提交“重新应用”在远程提交之后。</li><li><strong>结果</strong>： <ul><li>提交历史是直线的。</li><li>不会生成额外的 merge commit。</li></ul></li><li><strong>优点</strong>： <ul><li>历史干净，容易阅读。</li></ul></li><li><strong>缺点</strong>： <ul><li>会改写提交的 hash（因为 rebase 会重放提交）。</li><li>如果已经 push 过，再 rebase 可能要强推（<code>git push -f</code>），这对协作有风险。</li></ul></li></ul><p>📌 举个例子：</p><div class="language-text line-numbers-mode" data-highlighter="prismjs" data-ext="text" data-title="text"><pre><code><span class="line">A---B---C (你的本地提交)</span>
<span class="line">     \\</span>
<span class="line">      D---E (远程提交)</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>执行 <code>git pull --rebase</code> 后：</p><div class="language-text line-numbers-mode" data-highlighter="prismjs" data-ext="text" data-title="text"><pre><code><span class="line">A---B---D---E---C&#39; (C 被“重放”，变成新的提交 C&#39;)</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><h4 id="🔑-总结" tabindex="-1"><a class="header-anchor" href="#🔑-总结"><span>🔑 总结</span></a></h4><ul><li><strong><code>--no-rebase</code></strong>：保留真实的合并历史，适合强调“分支合并点”的团队。</li><li><strong><code>--rebase</code></strong>：让历史线性、干净，适合强调“整洁提交线”的团队。</li></ul><p>👉 通常：</p><ul><li><strong>开源项目 / 大团队</strong>：偏向 <strong>merge</strong>（避免重写别人提交的历史）。</li><li><strong>小团队 / 自己的项目</strong>：偏向 <strong>rebase</strong>（历史整洁）。</li></ul><hr><h3 id="git-pull-ff-only的理解" tabindex="-1"><a class="header-anchor" href="#git-pull-ff-only的理解"><span><code>git pull --ff-only</code>的理解:</span></a></h3><h4 id="🚀-什么是-fast-forward-快进合并" tabindex="-1"><a class="header-anchor" href="#🚀-什么是-fast-forward-快进合并"><span>🚀 什么是 fast-forward (快进合并)</span></a></h4><p>Git 有两种主要的合并方式：</p><ol><li><p><strong>普通合并 (merge)</strong></p><ul><li>如果两个分支有分叉，Git 会创建一个新的 <strong>merge commit</strong> 来把两条线合并在一起。</li></ul></li><li><p><strong>快进合并 (fast-forward)</strong></p><ul><li>如果当前分支的 <strong>HEAD 落后于远程分支</strong>，而且 <strong>本地没有额外的提交</strong>，Git 就可以“直接把 HEAD 向前移动到远程最新提交”。</li><li>这种情况不需要生成新的 commit，历史就像直接从远程走过来的一样。</li></ul></li></ol><h4 id="📌-举个例子" tabindex="-1"><a class="header-anchor" href="#📌-举个例子"><span>📌 举个例子</span></a></h4><p>远程分支：</p><div class="language-text line-numbers-mode" data-highlighter="prismjs" data-ext="text" data-title="text"><pre><code><span class="line">A---B---C---D (origin/main)</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>本地分支：</p><div class="language-text line-numbers-mode" data-highlighter="prismjs" data-ext="text" data-title="text"><pre><code><span class="line">A---B---C (main)</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>这时执行：</p><div class="language-bash line-numbers-mode" data-highlighter="prismjs" data-ext="sh" data-title="sh"><pre><code><span class="line"><span class="token function">git</span> pull --ff-only</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>Git 会直接把 <code>main</code> 指针移动到 <code>D</code>，结果是：</p><div class="language-text line-numbers-mode" data-highlighter="prismjs" data-ext="text" data-title="text"><pre><code><span class="line">A---B---C---D (main, origin/main)</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>没有产生额外的 commit，历史是线性的。</p><h4 id="🛑-如果不能快进会怎样" tabindex="-1"><a class="header-anchor" href="#🛑-如果不能快进会怎样"><span>🛑 如果不能快进会怎样？</span></a></h4><p>比如本地有提交：</p><div class="language-text line-numbers-mode" data-highlighter="prismjs" data-ext="text" data-title="text"><pre><code><span class="line">A---B---C---X (main)</span>
<span class="line">     \\</span>
<span class="line">      D---E (origin/main)</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这种情况 <strong>没法快进</strong>（因为有分叉）， 执行 <code>git pull --ff-only</code> 会报错：</p><div class="language-text line-numbers-mode" data-highlighter="prismjs" data-ext="text" data-title="text"><pre><code><span class="line">fatal: Not possible to fast-forward, aborting.</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>这样避免了 Git 自动生成 merge commit，让你自己决定是要 <code>--rebase</code> 还是 <code>--no-rebase</code>。</p><h4 id="✅-总结理解" tabindex="-1"><a class="header-anchor" href="#✅-总结理解"><span>✅ 总结理解</span></a></h4><ul><li><strong><code>git pull --ff-only</code></strong> = 只允许快进更新，不允许自动 merge。</li><li><strong>适用场景</strong>： <ul><li>你本地没有提交，只是想更新远程代码。</li><li>想确保历史干净，不要多余的 merge commit。</li></ul></li><li><strong>好处</strong>：安全、整洁。不会悄悄帮你合并。</li><li><strong>坏处</strong>：如果有分叉，它会报错，你得自己决定怎么解决。</li></ul><hr><h4 id="和-git-pull的区别" tabindex="-1"><a class="header-anchor" href="#和-git-pull的区别"><span>和 git pull的区别:</span></a></h4><h5 id="_1️⃣-git-pull-默认行为" tabindex="-1"><a class="header-anchor" href="#_1️⃣-git-pull-默认行为"><span>1️⃣ <code>git pull</code> 默认行为</span></a></h5><ul><li>默认其实是相当于：</li></ul><div class="language-bash line-numbers-mode" data-highlighter="prismjs" data-ext="sh" data-title="sh"><pre><code><span class="line"><span class="token function">git</span> fetch</span>
<span class="line"><span class="token function">git</span> merge origin/当前分支</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>也就是说，如果本地和远程有分歧（divergent branches），Git 会 <strong>生成一个 merge commit</strong> 来合并两边的历史。</li><li>优点：保证不会丢提交，安全</li><li>缺点：可能产生额外的 merge commit，历史不够干净</li></ul><h5 id="_2️⃣-git-pull-ff-only" tabindex="-1"><a class="header-anchor" href="#_2️⃣-git-pull-ff-only"><span>2️⃣ <code>git pull --ff-only</code></span></a></h5><ul><li>只允许 <strong>快进更新</strong>，不会生成 merge commit</li><li>如果本地分支有任何提交（包括 Git 自动生成的 merge commit），<strong>就会报错</strong></li><li>优点：历史干净、线性</li><li>缺点：不是快进的情况必须手动处理</li></ul><h5 id="_3️⃣-为什么不直接用-git-pull" tabindex="-1"><a class="header-anchor" href="#_3️⃣-为什么不直接用-git-pull"><span>3️⃣ 为什么不直接用 <code>git pull</code>？</span></a></h5><ul><li>直接 <code>git pull</code> 会自动 merge，如果你本地有 <strong>意外的 commit</strong>（例如 Git 自动生成的 merge commit），就可能： <ol><li>生成新的 merge commit</li><li>导致历史不干净</li></ol></li><li>有些团队或个人非常强调 <strong>提交历史线性</strong>，不希望出现多余的 merge commit，这时候就会选择 <code>--ff-only</code> 或 <code>--rebase</code></li></ul><h5 id="_4️⃣-总结理解" tabindex="-1"><a class="header-anchor" href="#_4️⃣-总结理解"><span>4️⃣ 总结理解</span></a></h5><table><thead><tr><th>命令</th><th>本地干净</th><th>本地有提交</th><th>历史结果</th><th>安全性/清洁度</th></tr></thead><tbody><tr><td><code>git pull</code></td><td>✅</td><td>✅</td><td>merge commit 可能出现</td><td>安全，但历史可能杂乱</td></tr><tr><td><code>git pull --ff-only</code></td><td>✅</td><td>❌（报错）</td><td>快进，历史线性</td><td>历史干净，但不能有本地提交</td></tr><tr><td><code>git pull --rebase</code></td><td>✅</td><td>✅</td><td>历史线性</td><td>历史干净，但重写本地提交，需注意 push</td></tr></tbody></table><p>💡 <strong>核心理解</strong>：</p><ul><li><code>git pull</code> = 安全默认，但可能产生 merge commit</li><li><code>--ff-only</code> = 历史干净，但严格要求本地无提交</li><li><code>--rebase</code> = 历史干净，可处理本地提交，但改写历史</li></ul>`,64)]))}const o=s(i,[["render",t],["__file","git之pull报错问题.html.vue"]]),p=JSON.parse('{"path":"/content/other/git/git%E4%B9%8Bpull%E6%8A%A5%E9%94%99%E9%97%AE%E9%A2%98.html","title":"git之pull报错问题","lang":"en-US","frontmatter":{"sidebar":false,"title":"git之pull报错问题","head":[["meta",{"name":"title","content":"git之pull报错问题"}],["meta",{"name":"description","content":"git之pull报错问题"}],["meta",{"name":"keywords","content":"git"}],["meta",{"property":"og:title","content":"git之pull报错问题"}],["meta",{"property":"og:description","content":"git之pull报错问题"}]]},"headers":[{"level":3,"title":"git之pull报错问题","slug":"git之pull报错问题","link":"#git之pull报错问题","children":[]},{"level":3,"title":"git pull --no-rebase  和 --rebase的区别:","slug":"git-pull-no-rebase-和-rebase的区别","link":"#git-pull-no-rebase-和-rebase的区别","children":[]},{"level":3,"title":"git pull --ff-only的理解:","slug":"git-pull-ff-only的理解","link":"#git-pull-ff-only的理解","children":[]}],"git":{},"filePathRelative":"content/other/git/git之pull报错问题.md"}');export{o as comp,p as data};
