import{_ as s,c as a,d as t,o as e}from"./app-CHrRue27.js";const p={};function o(l,n){return e(),a("div",null,n[0]||(n[0]=[t(`<h5 id="时间复杂度-关于-o-n-和-o-log-n-的定义" tabindex="-1"><a class="header-anchor" href="#时间复杂度-关于-o-n-和-o-log-n-的定义"><span>时间复杂度-关于 O(n) 和 O(log n)的定义</span></a></h5><p>“O(n)” 和 “O(log n)” 是算法分析中的<strong>时间复杂度</strong>（Time Complexity）表示方式，用来衡量算法随着输入规模增大时，运行时间的增长趋势。我们来详细对比这两者：</p><hr><h5 id="🔢-o-n-线性时间复杂度" tabindex="-1"><a class="header-anchor" href="#🔢-o-n-线性时间复杂度"><span>🔢 O(n)（线性时间复杂度）</span></a></h5><ul><li><p><strong>含义</strong>：随着输入数据量 <code>n</code> 的增加，算法的运行时间也<strong>线性增加</strong>。</p></li><li><p><strong>举例</strong>：</p><div class="language-javascript line-numbers-mode" data-highlighter="prismjs" data-ext="js" data-title="js"><pre><code><span class="line"><span class="token keyword">function</span> <span class="token function">sum</span><span class="token punctuation">(</span><span class="token parameter">arr</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">  <span class="token keyword">let</span> total <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span></span>
<span class="line">  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> arr<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">    total <span class="token operator">+=</span> arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span></span>
<span class="line">  <span class="token punctuation">}</span></span>
<span class="line">  <span class="token keyword">return</span> total<span class="token punctuation">;</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这个函数会对每个元素做一次操作，所以时间复杂度是 <code>O(n)</code>。</p></li><li><p><strong>特点</strong>：</p><ul><li>效率中等；</li><li>适用于遍历型操作；</li><li>如果 <code>n = 1000</code>，就需要大约 1000 次操作。</li></ul></li></ul><hr><h5 id="🪜-o-log-n-对数时间复杂度" tabindex="-1"><a class="header-anchor" href="#🪜-o-log-n-对数时间复杂度"><span>🪜 O(log n)（对数时间复杂度）</span></a></h5><ul><li><p><strong>含义</strong>：随着 <code>n</code> 的增加，运行时间只增加对数倍数，增长非常慢。</p></li><li><p><strong>举例</strong>：二分查找：</p><div class="language-javascript line-numbers-mode" data-highlighter="prismjs" data-ext="js" data-title="js"><pre><code><span class="line"><span class="token keyword">function</span> <span class="token function">binarySearch</span><span class="token punctuation">(</span><span class="token parameter">arr<span class="token punctuation">,</span> target</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">  <span class="token keyword">let</span> left <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span></span>
<span class="line">  <span class="token keyword">let</span> right <span class="token operator">=</span> arr<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span></span>
<span class="line"></span>
<span class="line">  <span class="token keyword">while</span> <span class="token punctuation">(</span>left <span class="token operator">&lt;=</span> right<span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">    <span class="token keyword">let</span> mid <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">floor</span><span class="token punctuation">(</span><span class="token punctuation">(</span>left <span class="token operator">+</span> right<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">    <span class="token keyword">if</span> <span class="token punctuation">(</span>arr<span class="token punctuation">[</span>mid<span class="token punctuation">]</span> <span class="token operator">===</span> target<span class="token punctuation">)</span> <span class="token keyword">return</span> mid<span class="token punctuation">;</span></span>
<span class="line">    <span class="token keyword">if</span> <span class="token punctuation">(</span>arr<span class="token punctuation">[</span>mid<span class="token punctuation">]</span> <span class="token operator">&lt;</span> target<span class="token punctuation">)</span> left <span class="token operator">=</span> mid <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span></span>
<span class="line">    <span class="token keyword">else</span> right <span class="token operator">=</span> mid <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span></span>
<span class="line">  <span class="token punctuation">}</span></span>
<span class="line"></span>
<span class="line">  <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>每次都将搜索区间减半，所以是 <code>O(log n)</code>。</p></li><li><p><strong>特点</strong>：</p><ul><li>效率非常高；</li><li>常见于排序数组上的查找、树结构操作（如平衡二叉树）；</li><li>如果 <code>n = 1024</code>，最多只需要大约 <code>log₂(1024) = 10</code> 次操作！</li></ul></li></ul><hr><h5 id="⛳-比较总结" tabindex="-1"><a class="header-anchor" href="#⛳-比较总结"><span>⛳ 比较总结</span></a></h5><table><thead><tr><th>时间复杂度</th><th>操作数增长</th><th>举例</th><th>效率</th></tr></thead><tbody><tr><td>O(n)</td><td>成正比</td><td>遍历数组</td><td>中等</td></tr><tr><td>O(log n)</td><td>成对数增长</td><td>二分查找</td><td>非常高效</td></tr></tbody></table><h5 id="可视化对比-大致数量" tabindex="-1"><a class="header-anchor" href="#可视化对比-大致数量"><span>可视化对比（大致数量）：</span></a></h5><table><thead><tr><th>n 值</th><th>O(n) 操作次数</th><th>O(log n) 操作次数</th></tr></thead><tbody><tr><td>10</td><td>10</td><td>4</td></tr><tr><td>100</td><td>100</td><td>7</td></tr><tr><td>1000</td><td>1000</td><td>10</td></tr><tr><td>1,000,000</td><td>1,000,000</td><td>20</td></tr></tbody></table><hr>`,14)]))}const i=s(p,[["render",o],["__file","时间复杂度.html.vue"]]),r=JSON.parse('{"path":"/content/other/spread/%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6.html","title":"时间复杂度","lang":"en-US","frontmatter":{"sidebar":false,"title":"时间复杂度","head":[["meta",{"name":"title","content":"时间复杂度"}],["meta",{"name":"description","content":"时间复杂度"}],["meta",{"name":"keywords","content":"时间复杂度"}],["meta",{"property":"og:title","content":"时间复杂度"}],["meta",{"property":"og:description","content":"时间复杂度"}]]},"headers":[],"git":{},"filePathRelative":"content/other/spread/时间复杂度.md"}');export{i as comp,r as data};
