import{_ as o,c,d as a,o as d}from"./app-CHrRue27.js";const r={};function n(s,e){return d(),c("div",null,e[0]||(e[0]=[a(`<h3 id="docker之cp在两种挂载方式上的表现" tabindex="-1"><a class="header-anchor" href="#docker之cp在两种挂载方式上的表现"><span>docker之cp在两种挂载方式上的表现</span></a></h3><h4 id="docker-cp-的作用在-命名卷-的使用" tabindex="-1"><a class="header-anchor" href="#docker-cp-的作用在-命名卷-的使用"><span><code>docker cp</code> 的作用在 <strong>命名卷</strong> 的使用</span></a></h4><ul><li><code>docker cp &lt;宿主机路径&gt; &lt;容器:路径&gt;</code></li><li><code>docker cp &lt;容器:路径&gt; &lt;宿主机路径&gt;</code></li></ul><p>它是直接在 <strong>宿主机文件系统</strong> 和 <strong>容器文件系统（mount namespace 里的视角）</strong> 之间拷贝文件。 它<strong>并不直接操作 volume 对象</strong>。</p><hr><h4 id="对于-命名卷-的情况" tabindex="-1"><a class="header-anchor" href="#对于-命名卷-的情况"><span>对于 <strong>命名卷</strong> 的情况</span></a></h4><p>命名卷会挂载到容器里的某个目录，比如：</p><div class="language-bash line-numbers-mode" data-highlighter="prismjs" data-ext="sh" data-title="sh"><pre><code><span class="line"><span class="token function">docker</span> run <span class="token parameter variable">-d</span> <span class="token parameter variable">-v</span> myvolume:/app/data myimage</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>这里：</p><ul><li><code>myvolume</code> → 实际在宿主机 <code>/var/lib/docker/volumes/myvolume/_data</code> 下存储</li><li>容器内 <code>/app/data</code> → 就是这个卷的挂载点</li></ul><p>因此：</p><ul><li>你用 <code>docker cp somefile.txt mycontainer:/app/data/</code> <strong>可以把文件复制到卷里</strong>（因为容器的 <code>/app/data</code> 就是那个卷）。</li><li>同样 <code>docker cp mycontainer:/app/data/file.txt ./</code> <strong>可以把卷里的内容拷贝出来</strong>。</li></ul><h4 id="另一种方式-不通过-docker-cp" tabindex="-1"><a class="header-anchor" href="#另一种方式-不通过-docker-cp"><span>另一种方式（不通过 <code>docker cp</code>）</span></a></h4><p>因为命名卷在宿主机上实际存放在 <code>/var/lib/docker/volumes/...</code>，所以也可以直接去这个目录修改内容。但：</p><ul><li>这种方式依赖 Docker 内部实现路径，不同系统可能不同。</li><li>权限可能麻烦。</li><li>一般不推荐，除非明确知道自己在做什么。</li></ul><p>✅ 结论： 在容器挂载了命名卷的情况下，可以用 <code>docker cp</code> 来复制文件到容器指定路径，从而间接写入卷。</p><hr><h4 id="docker-cp-的作用在-绑定挂载-下使用会报-device-or-resource-busy-之类的错误。" tabindex="-1"><a class="header-anchor" href="#docker-cp-的作用在-绑定挂载-下使用会报-device-or-resource-busy-之类的错误。"><span><code>docker cp</code> 的作用在 <strong>绑定挂载</strong> 下使用会报 <em>device or resource busy</em> 之类的错误。</span></a></h4><p>这个和 <strong>绑定挂载 (bind mount)</strong> 的工作方式有关，拆开分析一下为什么 <code>docker cp</code> 在绑定挂载时容易报 <em>device or resource busy</em> 之类的错误。</p><h4 id="_1-为什么命名卷能用-docker-cp" tabindex="-1"><a class="header-anchor" href="#_1-为什么命名卷能用-docker-cp"><span>1. 为什么命名卷能用 <code>docker cp</code></span></a></h4><ul><li><strong>命名卷</strong>（<code>-v myvolume:/app/data</code>）：容器里的 <code>/app/data</code> 是挂载点，底层在 <code>/var/lib/docker/volumes/.../_data</code>。</li><li>当你执行 <code>docker cp ./conf mycontainer:/app/data/</code> 时，Docker 直接把文件复制到容器的挂载路径里 → 实际就是写入到卷目录。</li><li>Docker 在这个过程中“中转”了一下数据，不会直接和宿主机文件系统产生冲突，所以不会报 <em>busy</em>。</li></ul><h4 id="_2-为什么绑定挂载会出问题" tabindex="-1"><a class="header-anchor" href="#_2-为什么绑定挂载会出问题"><span>2. 为什么绑定挂载会出问题</span></a></h4><ul><li><p><strong>绑定挂载</strong>（<code>-v /host/path:/app/data</code>）：容器里的 <code>/app/data</code> <strong>就是宿主机的 <code>/host/path</code></strong>。</p></li><li><p>如果你执行</p><div class="language-bash line-numbers-mode" data-highlighter="prismjs" data-ext="sh" data-title="sh"><pre><code><span class="line"><span class="token function">docker</span> <span class="token function">cp</span> ./conf mycontainer:/app/data/</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>Docker 的逻辑是：</p><ol><li>宿主机 → 容器文件系统</li><li>发现 <code>/app/data</code> 实际上是 <strong>一个 bind mount</strong></li><li>容器内的路径和宿主机的路径直接映射 → Docker 需要在宿主机上对 <code>/host/path</code> 直接操作</li></ol></li><li><p>这时候如果 <code>/host/path</code> <strong>被容器占用（例如进程持有 fd、锁住文件）</strong>，就可能触发 <code>device or resource busy</code> 报错。</p></li></ul><h4 id="_3-生产环境为什么常用-docker-cp" tabindex="-1"><a class="header-anchor" href="#_3-生产环境为什么常用-docker-cp"><span>3. 生产环境为什么常用 <code>docker cp</code></span></a></h4><ul><li><p><strong>绑定挂载</strong>虽然方便实时调试，但生产环境往往不适合，因为：</p><ul><li>宿主机路径和容器耦合太强，迁移麻烦</li><li>权限、安全风险高</li><li><code>docker cp</code> 这类操作更容易冲突</li></ul></li><li><p><strong>命名卷</strong>则更稳定，<code>docker cp</code> 可以安全地注入配置文件，容器重建时卷还在，数据不会丢。</p></li></ul><h4 id="_4-推荐的做法-生产环境" tabindex="-1"><a class="header-anchor" href="#_4-推荐的做法-生产环境"><span>4. 推荐的做法（生产环境）</span></a></h4><ol><li><p><strong>初始化配置文件</strong></p><ul><li>在镜像里放默认配置</li><li>或者容器启动后用 <code>docker cp</code> 写入一次配置文件到命名卷</li></ul></li><li><p><strong>更新配置文件</strong></p><ul><li>用 <code>docker cp</code> 再次覆盖目标路径（命名卷安全）</li><li>或者提供一个 API / reload 脚本在容器内拉取最新配置</li></ul></li><li><p><strong>避免在生产里用绑定挂载</strong></p><ul><li>除非是日志输出到宿主机目录（相对安全）</li><li>否则配置、数据目录最好用卷</li></ul></li></ol><p>✅ 总结：</p><ul><li><code>docker cp</code> 在 <strong>命名卷</strong> 下可行、安全，适合生产。</li><li>在 <strong>绑定挂载</strong> 下可能报 busy 错误，因为容器进程会锁定挂载目录里的文件。</li><li>所以生产一般不用 bind mount，而是用命名卷 + <code>docker cp</code> 或配置管理工具。</li></ul>`,29)]))}const t=o(r,[["render",n],["__file","docker之cp在两种挂载方式上的表现.html.vue"]]),i=JSON.parse('{"path":"/content/service/docker/docker%E4%B9%8Bcp%E5%9C%A8%E4%B8%A4%E7%A7%8D%E6%8C%82%E8%BD%BD%E6%96%B9%E5%BC%8F%E4%B8%8A%E7%9A%84%E8%A1%A8%E7%8E%B0.html","title":"docker之cp在两种挂载方式上的表现","lang":"en-US","frontmatter":{"sidebar":false,"title":"docker之cp在两种挂载方式上的表现","head":[["meta",{"name":"title","content":"docker之cp在两种挂载方式上的表现"}],["meta",{"name":"description","content":"docker之cp在两种挂载方式上的表现"}],["meta",{"name":"keywords","content":"Haproxy,Docker"}],["meta",{"property":"og:title","content":"docker之cp在两种挂载方式上的表现"}],["meta",{"property":"og:description","content":"docker之cp在两种挂载方式上的表现"}]]},"headers":[{"level":3,"title":"docker之cp在两种挂载方式上的表现","slug":"docker之cp在两种挂载方式上的表现","link":"#docker之cp在两种挂载方式上的表现","children":[]}],"git":{},"filePathRelative":"content/service/docker/docker之cp在两种挂载方式上的表现.md"}');export{t as comp,i as data};
