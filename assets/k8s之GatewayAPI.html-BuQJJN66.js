import{_ as n,c as a,d as e,o as l}from"./app-CHrRue27.js";const i={};function t(p,s){return l(),a("div",null,s[0]||(s[0]=[e(`<p>最近抽时间看了k8s的Gateway Api部分，在这里记录一下:</p><div class="language-text line-numbers-mode" data-highlighter="prismjs" data-ext="text" data-title="text"><pre><code><span class="line">1.GatewayClass定义了一组共享共同配置和行为的网关。每个GatewayClass将由一个控制器处理，尽管控制器可以处理一个以上的GatewayClass。//所以可以看到每个GatewayClass的spec的controllerName会指定一个ateway-api的实现，比如Kong的(kic)</span>
<span class="line"></span>
<span class="line">GatewayClass是一个集群范围的资源。必须至少有一个GatewayClass被定义，以便能够有功能性的Gateway。实现Gateway API的控制器通过提供一个相关的GatewayClass资源来实现，用户可以从他们的Gateway（s）中引用。</span>
<span class="line"></span>
<span class="line">这与Ingress的IngressClass和PersistentVolumes的StorageClass类似。在Ingress v1beta1中，与GatewayClass最接近的类似物是ingress-class注解，而在IngressV1中，最接近的类似物是IngressClass对象。</span>
<span class="line"></span>
<span class="line"></span>
<span class="line">2.网关描述了如何将流量转化为集群内的服务。也就是说，它定义了一个请求，要求将流量从不了解Kubernetes的地方转换到了解的地方。例如，由云负载平衡器、集群内代理或外部硬件负载平衡器发送到Kubernetes服务的流量。虽然许多用例都有来自集群 &quot;外部 &quot;的客户端流量，但这并不是一个要求。</span>
<span class="line"></span>
<span class="line">它定义了对特定负载平衡器配置的请求，该配置实现了GatewayClass的配置和行为契约。该资源可以由操作员直接创建，也可以由处理GatewayClass的控制器创建。</span>
<span class="line"></span>
<span class="line">由于Gateway规范捕获了用户的意图，它可能不包含规范中所有属性的完整规范。例如，用户可以省略诸如地址、TLS设置等字段。这允许管理GatewayClass的控制器为用户提供这些设置，从而产生一个更可移植的规范。这种行为将通过GatewayClass状态对象来明确。</span>
<span class="line"></span>
<span class="line">一个Gateway可以被附加到一个或多个路由引用上，这些路由引用的作用是将流量的一个子集导向一个特定的服务</span>
<span class="line"></span>
<span class="line">3.路由资源定义了特定的协议规则，用于将请求从网关映射到Kubernetes服务。</span>
<span class="line"></span>
<span class="line">从v1alpha2版开始，API中包含了四种路由资源类型。我们鼓励为其他协议定制特定实现的路由类型。未来可能会在API中加入新的路由类型。</span>
<span class="line"></span>
<span class="line"></span>
<span class="line">HTTPRoute: HTTPRoute用于复用HTTP或终止的HTTPS连接。它的目的是在你想检查HTTP流并使用HTTP请求数据进行路由或修改的情况下使用，例如使用HTTP Headers进行路由，或在飞行中修改它们。</span>
<span class="line">TLSRoute: TLSRoute用于复用TLS连接，通过SNI进行区分。它适用于你想使用SNI作为主要的路由方法，而对HTTP等高级协议的属性不感兴趣的情况。连接的字节流被代理，没有任何检查到后端</span>
<span class="line">TCPRoute and UDPRoute: TCPRoute（和UDPRoute）旨在用于将一个或多个端口映射到一个后端。在这种情况下，没有可以用来选择同一端口的不同后端的判别器，所以每个TCPRoute在监听器上确实需要一个不同的端口（无论如何，一般来说）。你可以终止TLS，在这种情况下，未加密的字节流被传递到后端。你可以选择不终止TLS，在这种情况下，加密的字节流被传递到后端。</span>
<span class="line">GRPCRoute: GRPCRoute是用于习惯性地路由gRPC流量。支持GRPCRoute的网关需要支持HTTP/2，而不需要从HTTP/1进行初始升级，因此保证gRPC流量的正常流动。</span>
<span class="line"></span>
<span class="line"></span>
<span class="line"></span>
<span class="line">对于使用反向代理实现的网关，典型的客户/网关API请求流是：</span>
<span class="line"></span>
<span class="line">客户端向 http://foo.example.com 发出请求。</span>
<span class="line">DNS将该名称解析为一个网关地址。//文档中的测试链接:$ curl -s -I -HHost:httpbin.example.com &quot;http://$INGRESS_HOST/get&quot;，先获取 $INGRESS_HOST,这个是一个IP地址，curl 访问这个IP地址，同时通过-H参数指定将要访问的hostName，和直接访问这个hostName效果相同;只不过测试的时候这个hostName还没有配置NDS域名解析。和 </span>
<span class="line">curl http://example.com/version --resolve example.com:80:&lt;EXTERNAL-IP&gt; 也是相同的效果</span>
<span class="line"></span>
<span class="line">反向代理在监听器上接收请求，并使用主机头来匹配HTTPRoute。</span>
<span class="line">可选的是，反向代理可以根据HTTPRoute的匹配规则执行请求头和/或路径匹配。</span>
<span class="line">可选的是，反向代理可以根据HTTPRoute的过滤规则修改请求，即添加/删除头信息。</span>
<span class="line">最后，反向代理根据HTTPRoute的backendRefs规则，将请求转发给集群中的一个或多个对象，即服务。</span>
<span class="line"></span>
<span class="line"></span>
<span class="line"></span>
<span class="line">https://help.aliyun.com/document_detail/480188.html //利用gateway-api访问服务</span>
<span class="line">https://www.alibabacloud.com/help/zh/alibaba-cloud-service-mesh/latest/use-gateway-api-to-define-a-routing-rule //利用gateway-api定义路由规则，这个里面有获取网关入口的方法</span>
<span class="line"></span>
<span class="line">https://gateway-api.sigs.k8s.io/references/spec/#gateway.networking.k8s.io/v1beta1.Hostname //gateway-api各个参数配置，其中有 介绍 Gateway的listeners的address属性，这个如果不配置的话，会自动生成</span>
<span class="line"></span>
<span class="line"></span>
<span class="line">istio 配置gateway api的网关(https://istio.io/latest/zh/docs/tasks/traffic-management/ingress/ingress-control):</span>
<span class="line">您可以使用类似的命令找到任何网关上的其他端口。 例如在名为 my-gateway 的网关上访问名为 https 的安全 HTTP 端口：</span>
<span class="line">export INGRESS_HOST=$(kubectl get gtw my-gateway -o jsonpath=&#39;{.status.addresses[*].value}&#39;)</span>
<span class="line">export SECURE_INGRESS_PORT=$(kubectl get gtw my-gateway -o jsonpath=&#39;{.spec.listeners[?(@.name==&quot;https&quot;)].port}&#39;)</span>
<span class="line"></span>
<span class="line"></span>
<span class="line">执行如下指令，确定您的 Kubernetes 集群是否运行在支持外部负载均衡器的环境中：</span>
<span class="line">$ kubectl get svc &quot;$INGRESS_NAME&quot; -n &quot;$INGRESS_NS&quot;</span>
<span class="line">NAME                   TYPE           CLUSTER-IP       EXTERNAL-IP      PORT(S)   AGE</span>
<span class="line">istio-ingressgateway   LoadBalancer   172.21.109.129   130.211.10.121   ...       17h</span>
<span class="line"></span>
<span class="line">如果 EXTERNAL-IP 值已设置，说明环境正在使用外部负载均衡器，可以用其为 Ingress Gateway 提供服务。 如果 EXTERNAL-IP 值为 &lt;none&gt; （或持续显示 &lt;pending&gt;），说明环境没有为 Ingress Gateway 提供外部负载均衡器，无法使用 Ingress Gateway。</span>
<span class="line"></span>
<span class="line"></span>
<span class="line">Ingress Gateway 允许定义进入服务网格的流量入口，所有入站流量都通过该入口；Egress Gateway 与之相对，它定义了网格的流量出口。</span>
<span class="line"></span>
<span class="line">k8s的Gateway Api 是 Ingress Api的升级版本，目前还在开发中，很多服务商现在开始提供Gateway服务.</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>参考k8s官网:https://gateway-api.sigs.k8s.io/</p>`,3)]))}const d=n(i,[["render",t],["__file","k8s之GatewayAPI.html.vue"]]),v=JSON.parse('{"path":"/content/service/k8s/k8s%E4%B9%8BGatewayAPI.html","title":"k8s之GatewayAPI","lang":"en-US","frontmatter":{"sidebar":false,"title":"k8s之GatewayAPI","description":"k8s之GatewayAPI"},"headers":[],"git":{},"filePathRelative":"content/service/k8s/k8s之GatewayAPI.md"}');export{d as comp,v as data};
