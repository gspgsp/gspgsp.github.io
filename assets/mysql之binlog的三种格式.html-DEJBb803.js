import{_ as e,c as n,f as a,o as l}from"./app-BB_BIQV8.js";const o={};function i(t,s){return l(),n("div",null,s[0]||(s[0]=[a(`<p>mysql之binlog的三种格式:</p><div class="language-text line-numbers-mode" data-highlighter="prismjs" data-ext="text" data-title="text"><pre><code><span class="line">MySQL 提供了三种 binlog 格式，通过参数 binlog_format 设置：</span>
<span class="line">  </span>
<span class="line">STATEMENT（默认）：记录 SQL 语句。缺点是某些语句在复制时可能导致不一致（如非确定性函数）。</span>
<span class="line">ROW：记录每一行的更改，数据一致性高，但生成日志量大，适用于高一致性场景。</span>
<span class="line">MIXED：混合模式，MySQL 根据情况自动选择 STATEMENT 或 ROW 格式。</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>STATEMENT和ROW的区别，主要从 记录内容 和 一致性 两方面来解释:</p><h5 id="_1-statement-模式" tabindex="-1"><a class="header-anchor" href="#_1-statement-模式"><span>1. STATEMENT 模式</span></a></h5><ul><li><p><strong>记录内容</strong>：在 <code>STATEMENT</code> 模式下，binlog 日志只记录 SQL 语句本身。例如：</p><div class="language-sql line-numbers-mode" data-highlighter="prismjs" data-ext="sql" data-title="sql"><pre><code><span class="line"><span class="token keyword">UPDATE</span> users <span class="token keyword">SET</span> last_login <span class="token operator">=</span> <span class="token function">NOW</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">WHERE</span> id <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>这条语句会直接记录到 binlog 中，表示 “将 id 为 1 的用户的 last_login 字段更新为当前时间”。</p></li><li><p><strong>数据一致性问题</strong>：因为 <code>STATEMENT</code> 模式记录的是 SQL 语句，所以在执行时需要依赖运行时环境。如果在不同的数据库环境中执行该 SQL 语句，可能会导致不一致的结果。例如，<code>NOW()</code> 是一个<strong>非确定性函数</strong>，它在执行时返回的时间依赖于运行时的实际时间。</p><ul><li>在主从复制中，假设主库和从库的系统时间不同，那么 <code>NOW()</code> 的值就可能不同，这样在主库和从库中记录的 <code>last_login</code> 就会不一致。</li><li>类似的非确定性函数还包括 <code>RAND()</code>、<code>UUID()</code> 等，它们的执行结果每次都可能不同，因此 <code>STATEMENT</code> 模式在使用这些函数时容易导致数据不一致。</li></ul></li></ul><h5 id="_2-row-模式" tabindex="-1"><a class="header-anchor" href="#_2-row-模式"><span>2. ROW 模式</span></a></h5><ul><li><p><strong>记录内容</strong>：在 <code>ROW</code> 模式下，binlog 不记录 SQL 语句，而是直接记录<strong>行级别的数据更改</strong>。例如：</p><ul><li>假设执行一条 <code>UPDATE</code> 语句 <code>UPDATE users SET last_login = &#39;2024-11-10 12:00:00&#39; WHERE id = 1;</code></li><li>在 <code>ROW</code> 模式下，binlog 会直接记录 <code>id=1</code> 的用户 <code>last_login</code> 字段从旧值到新值的变化（即 <code>&#39;2024-11-10 12:00:00&#39;</code>），而不记录 <code>UPDATE</code> 语句本身。</li></ul></li><li><p><strong>数据一致性</strong>：因为 <code>ROW</code> 模式记录的是行的具体数据变化，所以无论在主库还是从库，直接按照数据变化来同步，不依赖运行时环境。因此即使是使用了非确定性函数，结果也会保持一致。</p></li><li><p><strong>日志量大</strong>：由于 <code>ROW</code> 模式记录的是具体的行变更，因此如果有大批量的更新操作（例如更新数千条数据），binlog 会将这些行的每一个更改记录下来，日志量会非常大。所以在数据更新量较大的场景中，<code>ROW</code> 模式可能会生成大量的日志。</p></li></ul><h5 id="举个例子来说明" tabindex="-1"><a class="header-anchor" href="#举个例子来说明"><span>举个例子来说明</span></a></h5><p>假设有一条语句：</p><div class="language-sql line-numbers-mode" data-highlighter="prismjs" data-ext="sql" data-title="sql"><pre><code><span class="line"><span class="token keyword">UPDATE</span> users <span class="token keyword">SET</span> score <span class="token operator">=</span> score <span class="token operator">+</span> <span class="token number">10</span> <span class="token keyword">WHERE</span> region <span class="token operator">=</span> <span class="token string">&#39;North&#39;</span><span class="token punctuation">;</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><ul><li><p><strong>在 <code>STATEMENT</code> 模式下</strong>，binlog 记录的就是这条 SQL 语句。执行时会对 <code>region = &#39;North&#39;</code> 的所有用户逐个增加 10 分。如果从库的 <code>users</code> 表数据与主库不完全一致，执行结果可能也会不同。</p></li><li><p><strong>在 <code>ROW</code> 模式下</strong>，binlog 不记录这条 SQL，而是直接记录每个符合条件的用户的 <code>score</code> 字段的具体变更。例如：</p><div class="language-text line-numbers-mode" data-highlighter="prismjs" data-ext="text" data-title="text"><pre><code><span class="line">id=2: score 从 50 变为 60</span>
<span class="line">id=5: score 从 70 变为 80</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><p>这样无论在主库还是从库，都只是直接应用这些行变更，不会因为数据库中的其他数据不同而产生不同的结果，保持数据一致性。</p></li></ul><h5 id="总结" tabindex="-1"><a class="header-anchor" href="#总结"><span>总结</span></a></h5><ul><li><code>STATEMENT</code> 模式日志量小，但对于使用非确定性函数的操作可能导致主从数据不一致。</li><li><code>ROW</code> 模式日志量大，但能保证数据操作的高一致性，非常适合需要数据完全一致的复制场景。</li></ul>`,13)]))}const c=e(o,[["render",i],["__file","mysql之binlog的三种格式.html.vue"]]),r=JSON.parse('{"path":"/content/database/mysql/mysql%E4%B9%8Bbinlog%E7%9A%84%E4%B8%89%E7%A7%8D%E6%A0%BC%E5%BC%8F.html","title":"mysql之binlog的三种格式","lang":"en-US","frontmatter":{"sidebar":false,"title":"mysql之binlog的三种格式","description":"mysql之binlog的三种格式"},"headers":[],"git":{},"filePathRelative":"content/database/mysql/mysql之binlog的三种格式.md"}');export{c as comp,r as data};
